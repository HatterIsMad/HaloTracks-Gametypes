-- /* GLOBAL VARIABLES */

alias	bestLapSeconds					= global.number[0]
alias	bestLapMilliseconds				= global.number[1]
alias	bestLapNumber					= global.number[2]
alias	frames							= global.number[3]
alias	framesOverflow					= global.number[4]
alias	host							= global.number[5]
alias	localCurrentLapSeconds			= global.number[6]
alias	localCurrentLapMilliseconds		= global.number[7]
alias	localLapFrames					= global.number[8]
alias	numberOfPlayers					= global.number[9]

alias	dashStatus						= global.number[10]
-- dashStatus = 0 -- Show Dash page 1
-- dashStatus = 1 -- Show Dash page 2
-- dashStatus = 2 -- Show Dash page 3
-- dashStatus = 3 -- Unused
-- dashStatus = 4 -- Show Post Race Dash

alias	raceStatus						= global.number[11]
-- raceStatus = 0 -- Game is starting, we haven't spawned yet
-- raceStatus = 1 -- Gridding has started
-- raceStatus = 2 -- Race has started
-- raceStatus = 3 -- Race time period has ended
-- raceStatus = 4 -- Race has ended

declare	bestLapSeconds					with network priority high
declare	bestLapMilliseconds				with network priority high
declare	bestLapNumber					with network priority high
declare	frames							with network priority high	= 0
declare	framesOverflow					with network priority high	= 1
declare	host							with network priority local	= 0
declare	localCurrentLapSeconds			with network priority local	= 0
declare	localCurrentLapMilliseconds		with network priority local	= 0
declare	dashStatus						with network priority local	= 0
declare	raceStatus						with network priority high	= 0


alias	bestLapPlayer					= global.player[0]
alias	client							= global.player[1]
alias	holeshotPlayer					= global.player[2]
declare bestLapPlayer					with network priority high
declare client							with network priority local
declare holeshotPlayer					with network priority local


alias	finalCheckpoint					= global.object[0]
alias	firstCheckpoint					= global.object[1]
alias	globalStorage					= global.object[2]

-- /* GLOBAL VARIABLES */



-- /* SCRIPT OPTIONS */

alias	numberOfLaps					= script_option[0]
alias	maxFuel							= script_option[1]
alias	refuelRate						= script_option[2]
alias	invincibility					= script_option[3]
alias	cvDelete						= script_option[4]
alias	requiredJokers					= script_option[5]
alias	waypointVisibility				= script_option[6]
alias	startGate						= script_option[7]
alias	defaultVehicle					= script_option[8]
alias	draft							= script_option[9]

-- /* SCRIPT OPTIONS */



-- /* PLAYER VARIABLES */

alias	position						= player.number[0]
alias	vehicleSpeedKPH					= player.number[1]
alias	currentFuelLevel				= player.number[2]
alias	currentLapMilliseconds			= player.number[3]
alias	widget21						= player.number[4]
alias	widget22						= player.number[5]
alias	widget11						= player.number[6]
alias	widget12						= player.number[7]
alias	vehicleRespawnTimer				= player.timer[0]
alias	onVehicle						= player.timer[1]
alias	offTrackDebounce				= player.timer[2]
alias	pitbox							= player.timer[3]

declare	player.position					with network priority high	= 1
declare	player.currentFuelLevel			with network priority high	= -30000
declare	player.vehicleSpeedKPH			with network priority local
declare	player.currentLapMilliseconds	with network priority local


declare	player.vehicleRespawnTimer		= 7
declare	player.pitbox					= 999


alias	vehicle							= player.object[0]
alias	timing							= player.object[1]
alias	storage							= player.object[2]
alias	storage2						= player.object[3]

alias	playerAhead						= player.player[0]
alias	playerBehind					= player.player[1]


alias	bestLapSeconds					= player.script_stat[0]
alias	bestLapMilliseconds				= player.script_stat[1]
alias	bestLapNumber					= player.script_stat[2]
alias	currentLapSeconds				= player.script_stat[3]

-- /* PLAYER VARIABLES */



-- /* OBJECT VARIABLES */


	-- /* Player Timing Object */
	alias	jokerCount						= object.number[0]
	alias	sectorTimeFrames				= object.number[1]
	alias	lapFrames						= object.number[2]
	alias	offTrackCount					= object.number[3]
	alias	penalty							= object.number[4]
	alias	currentCheckpoint				= object.number[5]
	alias	respawnTimers					= object.number[6]
	alias	bestSector1TimeFrames			= object.timer[0]
	alias	bestSector2TimeFrames			= object.timer[1]
	alias	bestSector3TimeFrames			= object.timer[2]
	alias	respawnTimer					= object.timer[3]
	alias	respawnObject					= object.object[0]
	alias	draftObject					    = object.object[1]
	-- /* Player Timing Object */


	-- /* Player Storage Object */
	alias	lapsAhead						= object.number[0]
	alias	lapsBehind						= object.number[1]
	alias	gapAheadSeconds					= object.number[2]
	alias	gapAheadMilliseconds			= object.number[3]
	alias	gapBehindSeconds				= object.number[4]
	alias	gapBehindMilliseconds			= object.number[5]
	alias	optimalLapSeconds				= object.number[6]
	alias	optimalLapMilliseconds			= object.number[7]
	alias	jokeredThisLap					= object.timer[0]
	alias	pittedThisLap					= object.timer[1]
	alias	sectorInvalidated				= object.timer[2]
	alias	lapInvalidated					= object.timer[3]
	-- /* Player Storage Object */


	-- /* Vehicle Object */
	alias	startingFuelSpeed				= object.number[0]
	alias	lapStartingFuel					= object.number[1]
	alias	fuelUsedLastLap					= object.number[2]
	alias	refuelAmount					= object.number[3]
	alias	fuelTaken						= object.number[4]
	alias	draftBonus						= object.number[5]
	alias	speedWarnings					= object.number[6]
	alias	bestSector1TimeFrames			= object.timer[0]
	alias	bestSector2TimeFrames			= object.timer[1]
	-- /* Vehicle Object */


	-- /* Checkpoint Object */
	alias	order							= object.number[0]
	alias	sector							= object.number[1]
	alias	bestSectorTimeFrames			= object.number[2]
	-- /* Checkpoint Object */


	-- /* Pit Box Object */
	alias	registrationTimer				= object.number[0]
	-- /* Pit Box Object */


	-- /* Grid Spot Object */
	alias	light							= object.object[0]
	-- /* Grid Spot Object */


	-- /* Light Object */
	alias	warnings							= object.number[0]
	-- /* Light Object */


	-- /* Global Storage Object */
	alias	maxFuelLevel					= object.number[0]
	alias	startGateFrame					= object.number[1]
	alias	startGateDropped				= object.number[2]
	alias	sectorCount						= object.number[3]
	alias	checkpointCount					= object.number[4]
	alias	pitLaneConfigured				= object.number[5]
	alias	waitForGridSpots				= object.number[6]
	-- /* Global Storage Object */


-- /* OBJECT VARIABLES */



-- /* HUD WIDGETS */

alias	topMiddleWidget					= script_widget[0]
alias	bottomMiddleWidget				= script_widget[1]
alias	topLeftWidget					= script_widget[2]
alias	bottomLeftWidget				= script_widget[3]

-- /* HUD WIDGETS */



-- # Functions #


alias framesIn = allocate temporary number
alias secondsOut = allocate temporary number
alias millisecondsOut = allocate temporary number
function timeFromFrames()
	secondsOut = framesIn
	secondsOut /= 60

	alias t = allocate temporary number
	t = secondsOut
	t *= 60

	millisecondsOut = framesIn
	millisecondsOut -= t
	millisecondsOut *= 1000
	millisecondsOut /= 60
end


-- # Functions #



-- # Initialize #

on init: do


	-- # Initialize Checkpoints #
	for each object with label "race_flag" do
		current_object.order = current_object.spawn_sequence
		current_object.team = neutral_team
		current_object.set_invincibility(1)


        if waypointVisibility >= 2 then
            current_object.set_waypoint_icon(diamond)
        end
        if waypointVisibility >= 3 then
			current_object.team = team[1]
        end


		if finalCheckpoint == no_object or current_object.order > finalCheckpoint.order then
			finalCheckpoint = current_object
		end

		if firstCheckpoint == no_object or current_object.order < firstCheckpoint.order then
			firstCheckpoint = current_object
		end

	end
	-- # Initialize Checkpoints #


	-- # Reorder Checkpoints #
	alias count = allocate temporary number
	count = 0
	for each object with label "race_flag" do

		-- # Find Next Checkpoint #
		alias nextCheckpointOrder = allocate temporary number
		nextCheckpointOrder = -1
		for each object with label "race_flag" do
			if nextCheckpointOrder < 0 and current_object.order >= count then
				nextCheckpointOrder = current_object.order
			end
			if current_object.order >= count and current_object.order < nextCheckpointOrder then
				nextCheckpointOrder = current_object.order
			end
		end
		-- # Find Next Checkpoint #

		-- # Change the order value on all checkpoints with that value #
		for each object with label "race_flag" do
			if nextCheckpointOrder >= 0 and nextCheckpointOrder == current_object.order then
				current_object.order = count
			end
		end
		-- # Change the order value on all checkpoints with that value #

		count += 1
	end
	-- # Reorder Checkpoints #


	-- # Create Object for storage #
	globalStorage = finalCheckpoint.place_at_me( hill_marker, none, never_garbage_collect, 0, 0, 0, none )
	-- # Create Object for storage #


	-- # Check to see if we have a pit lane configured #
	for each object with label "speed_limit" do
		globalStorage.pitLaneConfigured = 1
	end
	-- # Check to see if we have a pit lane configured #


	-- # Count Distinct Checkpoints #
	globalStorage.checkpointCount = 0
	for each object with label "race_flag" do
		for each object with label "race_flag" do
			if current_object.order == globalStorage.checkpointCount then
				globalStorage.checkpointCount += 1
			end
		end
	end
	-- # Count Distinct Checkpoints #


	-- # Figure out Checkpoint Sectors #
	do
		alias sector1 = allocate temporary object
		sector1 = no_object
		alias sector2 = allocate temporary object
		sector2 = no_object
		alias sector3 = allocate temporary object
		sector3 = no_object

		if globalStorage.checkpointCount <= 3 then
			for each object with label "race_flag" do
				if current_object.order == 0 then
					sector1 = current_object
				end
				if current_object.order == 1 then
					sector2 = current_object
				end
				if current_object.order == 2 then
					sector3 = current_object
				end
			end
		end


		alias spacing = allocate temporary number
		spacing = globalStorage.checkpointCount
		spacing /= 3
		alias order = allocate temporary number
		order = globalStorage.checkpointCount
		order -= 1
		order -= spacing

		if globalStorage.checkpointCount > 3 then
			sector3 = finalCheckpoint

			for each object with label "race_flag" do
				if current_object.order == order then
					sector2 = current_object
				end
			end

			order -= spacing

			for each object with label "race_flag" do
				if current_object.order == order then
					sector1 = current_object
				end
			end

		end


		if sector1 != no_object then
			globalStorage.sectorCount = 1
		end
		if sector2 != no_object then
			globalStorage.sectorCount = 2
		end
		if sector3 != no_object then
			globalStorage.sectorCount = 3
		end

		for each object with label "race_flag" do
			current_object.sector = 4

			if sector1 != no_object and current_object.order == sector1.order then
				current_object.sector = 1
			end
			if sector2 != no_object and current_object.order == sector2.order then
				current_object.sector = 2
			end
			if sector3 != no_object and current_object.order == sector3.order then
				current_object.sector = 3
			end
		end

	end
	-- # Figure out Checkpoint Sectors #


	-- # Hide Invisible Race Objects #
	for each object with label "race_hide" do
		current_object.set_hidden(true)
	end
	-- # Hide Invisible Race Objects #


	-- # Delete Competitive Version Objects #
	if cvDelete == 1 then
		for each object with label "cv_delete" do
			current_object.delete()
		end
	end
	-- # Delete Competitive Version Objects #


	-- # Set Start Gate Frame #
	if startGate == 1 then -- 20 +/- 5
		globalStorage.startGateFrame = rand( 601 )
		globalStorage.startGateFrame += 900
	end
	if startGate == 2 then -- 30 +/- 10
		globalStorage.startGateFrame = rand( 1201 )
		globalStorage.startGateFrame += 1200
	end
	if startGate == 3 then -- 40 +/- 20
		globalStorage.startGateFrame = rand( 2401 )
		globalStorage.startGateFrame += 1200
	end
	-- # Set Start Gate Frame #


	-- # Wait for grid spots #
	if startGate > 0 then
	    for each object with label "grid_spot" do
		    globalStorage.waitForGridSpots = 1
	    end
	end
	-- # Wait for grid spots #

	raceStatus = 1
	host = 1
end

-- # Initialize #



-- # Basic Game Logic #


	-- # Initial Spawn Point #
	for each player do
		if current_player.biped != no_object and current_player.storage2 == no_object then
			alias found = allocate temporary number
			found = 0

			-- # Check to ensure that grid spots exist on the map #
			for each object with label "grid_spot" do
				found = 1
			end
			-- # Check to ensure that grid spots exist on the map #

			if found == 1 then
			    -- # Check to see if the player is already assigned to a grid spot #
			    for each object with label "grid_spot" do
				    if current_object.player[0] == current_player then
					    current_player.storage2 = current_object
				    end
			    end
			    -- # Check to see if the player is already assigned to a grid spot #


			    if current_player.storage2 == no_object then
                    alias gridSpot = allocate temporary object
                    gridSpot = no_object

			        for each object with label "grid_spot" do
				        if current_object.player[0] == no_player then
				            if gridSpot == no_object or current_object.spawn_sequence < gridSpot.spawn_sequence then
				                gridSpot = current_object
				            end
				        end
			        end

			        if gridSpot != no_object then
                        current_player.storage2 = gridSpot
                        gridSpot.player[0] = current_player
			        end
			    end

			    -- # Spawn them at their grid spot #
                current_player.biped.attach_to(current_player.storage2, 0, 0, 2, relative)
                current_player.biped.detach()
                current_player.biped.copy_rotation_from(current_player.storage2, false)
			    -- # Spawn them at their grid spot #
			end
		end
	end
	-- # Initial Spawn Point #


	-- # Delete Race Gates #
	if startGate != 0 and raceStatus == 1 and globalStorage.startGateDropped == 0 and frames > globalStorage.startGateFrame and globalStorage.waitForGridSpots == 0 then
		for each object with label "race_gate" do
			current_object.delete()
		end
		raceStatus = 2
		frames = 0
		globalStorage.startGateDropped = 1

		for each player do
			if current_player.vehicleSpeedKPH > 10 then
				game.show_message_to(current_player, none, "You have earned yourself a 5s penalty bud" )
			end
		end
	end
	-- # Delete Race Gates #


	-- # Count number of alive players #
	numberOfPlayers = 0
	for each player do
		if current_player.biped != no_object then
			numberOfPlayers += 1
		end
	end
	-- # Count number of alive players #


	-- # If someone has met the number of laps, end the round #
	if numberOfLaps != 0 then
		for each player do
			if not current_player.score < numberOfLaps then
				raceStatus = 3
				game.end_round()
			end
		end
	end
	-- # If someone has met the number of laps, end the round #


	-- # If the round time limit has been exceeded, end the round #
	if game.round_time_limit > 0 and game.round_timer.is_zero() then
		raceStatus = 3
		game.end_round()
	end
	-- # If the round time limit has been exceeded, end the round #


	-- # Set up a 5 second timer #
	alias debounce5 = allocate temporary number
	debounce5 = 1

	if raceStatus >= 2 then
		alias tempNumber = allocate temporary number
		tempNumber = frames
		tempNumber /= 300
		tempNumber *= 300
		debounce5 = frames
		debounce5 -= tempNumber
	end
	-- # Set up a 5 second timer #


	for each player do

		-- # Set Shields #
		do
		    alias shields = allocate temporary number
		    shields = current_player.biped.shields
		    if shields > 0 then
		        if current_player.money <= 100 then
			        current_player.money = 300
		        end
		        current_player.biped.shields = current_player.money
		        current_player.biped.max_shields = current_player.money
		    end
		end
		-- # Set Shields #


		-- # Create Objects for storage #
		if current_player.timing == no_object then
			current_player.timing = current_player.biped.place_at_me(hill_marker, none,never_garbage_collect,0,0,0,none)
			--current_player.timing.attach_to(current_player.biped, 10, 0, 0, relative)
		end
		if current_player.storage == no_object then
			current_player.storage = current_player.biped.place_at_me(hill_marker, none,never_garbage_collect,0,0,0,none)
		end
		-- # Create Objects for storage #


		-- # Get Player Timing Object #
		alias timing = allocate temporary object
		timing = current_player.timing
		-- # Get Player Timing Object #


		-- # Get Player Storage Object #
		alias storage = allocate temporary object
		storage = current_player.storage
		-- # Get Player Storage Object #


		if current_player.biped == no_object then
			timing.respawnTimer += 1
			current_player.vehicle.set_invincibility( 0 )
			current_player.vehicle.kill( true )
		end

		current_player.biped.health = 100
        current_player.vehicle.set_invincibility( 1 )
        current_player.biped.remove_weapon(primary, true)


		-- # Police Track Limits #
		if cvDelete == 1 then
			for each object with label "track_limits" do
				if current_player.onVehicle == 1 and current_object.shape_contains(current_player.biped) and current_player.offTrackDebounce > 420 then
					timing.offTrackCount += 1
					alias penaltyLimit = allocate temporary number
					penaltyLimit = timing.offTrackCount
					penaltyLimit /= 5
					penaltyLimit += 1
					penaltyLimit *= 5
					alias penalty = allocate temporary number
					penalty = timing.offTrackCount
					penalty /= 5
					penalty *= 5

					if penalty == timing.offTrackCount then
						if timing.penalty < 0 then
							timing.penalty = 0
						end
						timing.penalty += 300
						game.show_message_to(current_player, none, "You have earned yourself a 5s penalty bud" )
					end
					if penalty != timing.offTrackCount then
						game.show_message_to(current_player, none, "You have exceeded track limits %n/%n times", timing.offTrackCount, penaltyLimit )
					end
					storage.sectorInvalidated = 1
					storage.lapInvalidated = 1
					current_player.offTrackDebounce = 0
				end
			end
			current_player.offTrackDebounce += 1
		end
		-- # Police Track Limits #


		-- # Set Current Lap time #
		current_player.currentLapSeconds = timing.lapFrames
		current_player.currentLapSeconds /= 60
		alias t = allocate temporary number
		t = current_player.currentLapSeconds
		t *= 60
		current_player.currentLapMilliseconds = timing.lapFrames
		current_player.currentLapMilliseconds -= t
		current_player.currentLapMilliseconds *= 1000
		current_player.currentLapMilliseconds /= 60
		-- # Set Current Lap time #


		-- # Set Player current racing position #
		alias racer = allocate temporary player
		racer = current_player
		alias position = allocate temporary number
		position = 1

		-- # Find out how many players are ahead #
		for each player do
			alias racerTiming = allocate temporary object
			racerTiming = current_player.timing

			if current_player.score > racer.score then
				position += 1
			end

			if current_player.score == racer.score then

				if timing.currentCheckpoint < racerTiming.currentCheckpoint then
					position += 1
				end

				if timing.currentCheckpoint == racerTiming.currentCheckpoint then
					if racerTiming.sectorTimeFrames > timing.sectorTimeFrames then
						position += 1
					end
				end

			end

		end
		-- # Find out how many players are ahead #

		current_player.position = position
		-- # Set Player current racing position #


		-- # Calculate Gaps #
		for each player do
			alias racer = allocate temporary player
			racer = current_player
			alias racerStorage = allocate temporary object
			racerStorage = racer.storage
			alias racerTiming = allocate temporary object
			racerTiming = current_player.timing
			alias tempPlayer = allocate temporary player
			tempPlayer = no_player
			racerStorage.lapsAhead = 0
			racerStorage.lapsBehind = 0

			-- # Find Player Ahead #
			racer.playerAhead = no_player
			alias positionAhead = allocate temporary number
			positionAhead = current_player.position
			positionAhead -= 1
			for each player do
				if positionAhead > 0 and current_player.position == positionAhead then
					racer.playerAhead = current_player
					tempPlayer = current_player
				end
			end

			if tempPlayer == no_player then
				racerStorage.gapAheadSeconds = 0
				racerStorage.gapAheadMilliseconds = 0
			end

			if tempPlayer != no_player then
				alias aheadTiming = allocate temporary object
				aheadTiming = tempPlayer.timing

				-- # Find out how many laps difference the player ahead is #
	            alias difference = allocate temporary number
	            difference = tempPlayer.score
	            difference -= current_player.score

	            if difference > 1 then
		            racerStorage.lapsAhead = difference
	            end
	            if difference == 1 then
		            racerStorage.lapsAhead = 0
		            if aheadTiming.currentCheckpoint > racerTiming.currentCheckpoint then
			            racerStorage.lapsAhead = 1
		            end
	            end
	            if difference <= 0 then
		            racerStorage.lapsAhead = 0
	            end
				-- # Find out how many laps difference the player ahead is #
			end
			-- # Find Player Ahead #


			-- # Find Player Behind #
			tempPlayer = no_player
			racer.playerBehind = no_player
			alias positionBehind = allocate temporary number
			positionBehind = current_player.position
			positionBehind += 1
			for each player do
				if positionBehind > 0 and current_player.position == positionBehind then
					racer.playerBehind = current_player
					tempPlayer = current_player
				end
			end

			if tempPlayer == no_player then
				racerStorage.gapBehindSeconds = 0
				racerStorage.gapBehindMilliseconds = 0
			end

			if tempPlayer != no_player then
				alias behindTiming = allocate temporary object
				behindTiming = tempPlayer.timing

				-- # Find out how many laps difference the player behind is #
	            alias difference = allocate temporary number
	            difference = current_player.score
	            difference -= tempPlayer.score

	            if difference > 1 then
		            racerStorage.lapsBehind = difference
	            end
	            if difference == 1 then
		            racerStorage.lapsBehind = 0
		            if racerTiming.currentCheckpoint > behindTiming.currentCheckpoint then
			            racerStorage.lapsBehind = 1
		            end
	            end
	            if difference <= 0 then
		            racerStorage.lapsBehind = 0
	            end
				-- # Find out how many laps difference the player behind is #

			end
			-- # Find Player Behind #

		end
		-- # Calculate Gaps #


		-- # Respawn Player #
		if current_player.biped != no_object and timing.respawnTimer >= 60 then
		    if timing.respawnObject == no_object and current_player.storage2 != no_object and current_player.storage2.has_forge_label("grid_spot") then
			    timing.respawnObject = current_player.storage2
		    end

		    if timing.respawnTimer >= 60 and timing.respawnObject != no_object then
                current_player.biped.attach_to(timing.respawnObject, 0, 0, 2, relative)
                current_player.biped.detach()
                current_player.biped.copy_rotation_from(timing.respawnObject, false)
       	    end
		    timing.respawnTimer = 0
		end
		-- # Respawn Player #

	end


	-- # Increment the frame counter #
	frames += 1
	if frames >= 30000 then
		frames -= 30000
		framesOverflow += 1
	end
	-- # Increment the frame counter #


	-- # Increment the player frame counters #
	if raceStatus >= 2 then
		for each player do
			alias timing = allocate temporary object
			timing = current_player.timing

			timing.lapFrames += 1 -- lapFrames
			timing.sectorTimeFrames += 1 -- sectorFrames
		end
	end
	-- # Increment the player frame counters #



	-- # Set up Grid Spot #
    for each object with label "grid_spot" do
        if raceStatus < 2 and startGate > 0 then
			if current_object.light == no_object then
				current_object.light = current_object.place_at_me(light_red, "race_gate", none, 7, 0, 2, none)
				current_object.light.set_scale(30)
			end

            current_object.set_shape(box, 10, 7, 2, 0)

			alias debounce = allocate temporary number
			debounce = frames
			debounce %= 60

			if current_object.light != no_object and debounce == 0 then
                alias light = allocate temporary object
                light = current_object.light

                for each player do
                    alias distance = allocate temporary number
                    distance = current_object.get_distance_to( current_player.biped )
                    if distance > 3 and distance < 8 then
                        current_object.set_shape_visibility(mod_player, current_player, 1)
                    end
                    if distance <= 3 or distance >= 9 then
                        current_object.set_shape_visibility(mod_player, current_player, 0)
                        current_object.set_shape(box, 10, 7, 10, 0)
                    end

                    if current_object.shape_contains( current_player.biped ) then
                        distance = light.get_distance_to( current_player.biped )

                        if distance < 9 then
                            if frames < 600 or light.warnings < 3 then
                                game.show_message_to(current_player, none, "You are too close. Move the fuck back." )
                                if globalStorage.waitForGridSpots == 0 then
                                    light.warnings += 1
                                end
                            end
                            if frames > 600 and light.warnings >= 3 then
								game.show_message_to(current_player, none, "You have earned yourself a 5s penalty bud" )
                                light.warnings = 0
                            end
                        end
                        if distance >= 9 and light.warnings > 0 then
                            light.warnings -= 1
                        end
                    end
                end
            end
        end
    end
	-- # Set up Grid Spot #



	-- # Handle Waypoint Priority #
	for each object do
		if current_object.has_forge_label("grid_spot") or current_object.has_forge_label("joker") or current_object.has_forge_label("speed_limit") or current_object.has_forge_label("race_flag") then
			if waypointVisibility == 1 then
				current_object.set_waypoint_priority(low)
			end
			if waypointVisibility >= 2 then
				current_object.set_waypoint_priority(normal)
			end
			if waypointVisibility >= 3 then
				current_object.set_waypoint_priority(high)
			end
		end
	end
	-- # Handle Waypoint Priority #


	-- # Check to see if everyone is on a grid spot #
	if globalStorage.waitForGridSpots == 1 and frames > 600 then
		alias ready = allocate temporary number
		ready = 1
		for each player do
			alias onABox = allocate temporary number
			onABox = 0
			for each object with label "grid_spot" do
				if current_object.shape_contains( current_player.biped ) then
					onABox = 1
				end
			end
			if onABox == 0 then
				ready = 0
			end
		end
		if ready == 1 then
			frames = 0
			globalStorage.waitForGridSpots = 0
			for each player do
				game.show_message_to(current_player, none, "The countdown has started" )
			end
		end
		if ready == 0 and frames > 1800 then
			alias debounce900 = allocate temporary number
			debounce900 = frames
			debounce900 %= 900
			if debounce900 == 0 then
				for each player do
					game.show_message_to(current_player, none, "Everyone must be sitting on a grid spot before the race can start." )
				end
			end
		end
	end
	-- # Check to see if everyone is on a grid spot #


	-- # Spectator Mode #
	for each object with label "Spectator" do
		for each player do

			-- # Transform Player into Monitor #
			if current_object.team == team[0] and current_object.shape_contains(current_player.biped) and not current_player.biped.is_of_type(monitor) then
                alias oldBody = allocate temporary object
                oldBody = current_player.biped
                oldBody.detach()
                current_player.vehicle.delete()
                alias mon = allocate temporary object
                mon = current_player.biped.place_at_me(monitor, none, never_garbage_collect, 0, 0, 5, none)
                mon.max_health = 100
                mon.set_invincibility(1)
                --mon.set_hidden(true)
                mon.remove_weapon(primary, true)
                current_player.set_biped(mon)
                oldBody.delete()
			end
			-- # Transform Player into Monitor #


			-- # Transform Player into Spartan #
			if current_object.team == team[1] and current_object.shape_contains(current_player.biped) and current_player.biped.is_of_type(monitor) then
                alias oldBody = allocate temporary object
                oldBody = current_player.biped
                oldBody.detach()
                alias mon = allocate temporary object
                mon = current_player.biped.place_at_me(spartan, none, never_garbage_collect, 0, 0, 5, none)
                mon.max_health = 100
                mon.remove_weapon(primary, true)
                current_player.set_biped(mon)
                oldBody.delete()
			end
			-- # Transform Player into Spartan #

		end
	end
	-- # Spectator Mode #


-- # Basic Game Logic #



-- # Handle Vehicles #

for each player do


	-- # Get players current Vehicle #
	alias vehicle = allocate temporary object
	vehicle = no_object
	vehicle = current_player.get_vehicle()
	-- # Get players current Vehicle #


	-- # Get players timing object #
	alias timing = allocate temporary object
	timing = no_object
	timing = current_player.timing
	-- # Get players timing object #


	-- # Remove the Players Vehicle if they die or quit #
	if current_player.killer_type_is(guardians | suicide | kill | betrayal | quit) then
		if current_player.vehicle != no_object then
			vehicle = current_player.vehicle
			if vehicle.player[0] == current_player or vehicle.player[0] == no_player then
				current_player.vehicle.delete()
				current_player.vehicle = no_object
				vehicle.delete()
				vehicle = no_object
			end
		end
	end
	-- # Remove the Players Vehicle if they die or quit #


	current_player.onVehicle = 0

    if not current_player.biped.is_of_type(monitor) then

	    -- # Check if Player is on vehicle #
	    if vehicle != no_object then
		    current_player.onVehicle = 1
	    end
	    -- # Check if Player is on vehicle #



	    -- # Handle the Player not being on a Vehicle #
	    if current_player.onVehicle == 0 then
		    if maxFuel == -1 or current_player.currentFuelLevel > 0 or current_player.currentFuelLevel == -30000 then

		    -- # Vehicle Respawn Timer has hit 0 #
		    if current_player.vehicleRespawnTimer.is_zero() then
			    if current_player.vehicle != no_object then
				    vehicle = current_player.vehicle
				    if vehicle.player[0] == current_player or vehicle.player[0] == no_player then
					    current_player.vehicle.delete()
					    current_player.vehicle = no_object
					    vehicle = no_object
				    end
			    end
			    current_player.vehicleRespawnTimer.reset()
		    end
		    -- # Vehicle Respawn Timer has hit 0 #


		    -- # If the Player doesn't have a vehicle, Put them in one #
		    if current_player.vehicle == no_object then
			    if defaultVehicle == 0 then
				    vehicle = current_player.biped.place_at_me(mongoose, "Vehicle", none, 0, 0, 0, none)
			    end
			    if defaultVehicle == 1 then
				    vehicle = current_player.biped.place_at_me(warthog, "Vehicle", none, 0, 0, 0, none)
			    end
			    if defaultVehicle == 2 then
				    vehicle = current_player.biped.place_at_me(warthog, "Vehicle", none, 0, 0, 0, troop)
			    end
			    if defaultVehicle == 3 then
				    vehicle = current_player.biped.place_at_me(pickup_truck, "Vehicle", none, 0, 0, 0, none)
			    end
			    vehicle.player[0] = current_player
			    current_player.vehicle = vehicle
			    current_player.force_into_vehicle(current_player.vehicle)
			    current_player.onVehicle = 1
		    end
		    -- # If the Player doesn't have a vehicle, Put them in one #


		    -- # If the Player still doesn't have a vehicle, start the Vehicle respawn timer #
		    current_player.vehicleRespawnTimer.set_rate(-100%)
		    -- # If the Player still doesn't have a vehicle, start the Vehicle respawn timer #


		    -- # Handle Abandoned Vehicles #
		    for each object with label "Vehicle" do
			    if current_object.player[0] == no_player then

				    -- # If the abandoned vehicle is near the Player, pair them #
				    if current_player.vehicle == no_object then
					    alias distance = allocate temporary number
					    distance = 0
					    distance = current_object.get_distance_to(current_player.biped)

					    if distance <= 100 then
						    current_object.player[0] = current_player
						    current_player.vehicle = current_object
					    end
				    end
				    -- # If the abandoned vehicle is near the Player, pair them #

			    end
		    end
		    -- # Handle Abandoned Vehicles #

		    end
	    end
	    -- # Handle the Player not being on a Vehicle #


	    -- # Handle the Player being on a Vehicle #
	    if current_player.onVehicle == 1 and vehicle.has_forge_label("Vehicle") then

		    -- # Reset Vehicle Respawn Timer #
		    current_player.vehicleRespawnTimer.reset()
		    -- # Reset Vehicle Respawn Timer #


		    -- # Player is on a new Vehicle #
		    if current_player.vehicle != vehicle then
			    current_player.vehicle = vehicle
			    alias oldPlayer = allocate temporary player
			    oldPlayer = vehicle.player[0]
			    oldPlayer.vehicle = no_object
			    vehicle.player[0] = current_player
		    end
		    -- # Player is on a new Vehicle #


		    -- # Ensure Player is only associated with one Vehicle #
		    for each object with label "Vehicle" do
			    if current_object != vehicle and current_object.player[0] == current_player then
				    current_object.player[0] = no_player
			    end
		    end
		    -- # Ensure Player is only associated with one Vehicle #


		    -- # Update Vehicle Speed #
		    current_player.vehicleSpeedKPH = 0
		    if current_player.biped != no_object then
			    current_player.vehicleSpeedKPH = current_player.biped.get_speed()
			    current_player.vehicleSpeedKPH *= 109 -- Convert from Feet Per Second to KMH
			    current_player.vehicleSpeedKPH /= 100 -- Convert from Feet Per Second to KMH

			    if current_player.vehicleSpeedKPH < 0 then
				    current_player.vehicleSpeedKPH = 0
			    end
			    if current_player.vehicleSpeedKPH > 200 then
				    current_player.vehicleSpeedKPH = 200
			    end
		    end
		    -- # Update Vehicle Speed #

	    end

	end
	-- # Handle the Player being on a Vehicle #


	-- # Set Player/Vehicle to Invincible if enabled in game options #
	if invincibility == 1 then
		current_player.biped.set_invincibility(1)
		current_player.vehicle.set_invincibility(1)
		for each object do
			if current_object.is_of_type(kill_boundary) or current_object.is_of_type(soft_kill_boundary) then
				for each player do
					if current_object.shape_contains(current_player.biped) and not current_player.biped.is_of_type(monitor) then
						current_player.biped.set_invincibility(0)
						current_player.vehicle.set_invincibility(0)
					end
				end
			end
		end
	end
	-- # Set Player/Vehicle to Invincible if enabled in game options #


	-- # Kill balls should kill players #
	for each object do
		if current_object.is_of_type(kill_ball) then
			for each player do
            	alias distance = allocate temporary number
            	distance = 0
            	distance = current_object.get_distance_to(current_player.biped)
				if distance < 25 then
					current_player.biped.set_invincibility(0)
					current_player.vehicle.set_invincibility(0)
					current_player.biped.kill(false)
					current_player.vehicle.kill(true)
				end
			end
		end
	end
	-- # Kill balls should kill players #


	-- # Ensure the draft object is created and attached to the vehicle #
	if draft != -1 then
		if timing.draftObject == no_object then
			timing.draftObject = current_player.biped.place_at_me( hill_marker, none, never_garbage_collect, 0, 0, 0, none )
		end
        timing.draftObject.attach_to(current_player.biped, 10, 0, 0, relative)
	end
	-- # Ensure the draft object is created and attached to the vehicle #

end


-- # Delete all unclaimed abandoned Vehicles #
for each object with label "Vehicle" do
	if current_object.player[0] == no_player then
		current_object.delete()
	end
	if current_object.player[0] != no_player then
		alias racer = allocate temporary player
		racer = current_object.player[0]

		if racer.biped == no_object then
			current_object.delete()
		end

		alias distance = allocate temporary number
		distance = 0
		distance = current_object.get_distance_to(racer.biped)

		if distance >= 200 then
			current_object.delete()
		end
	end
end
-- # Delete all unclaimed abandoned Vehicles #

-- # Handle Vehicles #



-- # Handle UI #

-- # Rotate Dash Status #
if debounce5 == 0 then
	if dashStatus != 4 then
		if dashStatus != 2 then
			dashStatus += 1
		end

		if dashStatus == 2 then
			dashStatus = 0
		end
	end
end
-- # Rotate Dash Status #



for each player do

	-- # Initialize UI #
	if numberOfLaps != 0 then
		current_player.set_objective_text("Hit checkpoints to complete laps.\r\n%n laps to win.", numberOfLaps)
	end
	if numberOfLaps == 0 then
		current_player.set_objective_text("Hit checkpoints to complete laps.")
	end
	-- # Initialize UI #


	-- # Don't display UI if race hasn't started or the Player is not on a mongoose #
	if raceStatus < 2 or current_player.onVehicle == 0 then
		topMiddleWidget.set_visibility(current_player, false)
		bottomMiddleWidget.set_visibility(current_player, false)
		topLeftWidget.set_visibility(current_player, false)
		bottomLeftWidget.set_visibility(current_player, false)
	end
	-- # Don't display UI if race hasn't started or the Player is not on a mongoose #


	-- # Don't display UI if race has started and the Player is on a mongoose #
	if raceStatus >= 2 and current_player.onVehicle == 1 then


		-- # Get Player Timing Object #
		alias timing = allocate temporary object
		timing = current_player.timing
		-- # Get Player Timing Object #


		-- # Get Player Storage Object #
		alias storage = allocate temporary object
		storage = current_player.storage
		-- # Get Player Storage Object #


		-- # Get Player Biped Object #
		alias biped = allocate temporary object
		biped = current_player.biped
		-- # Get Player Biped Object #


		-- # Get Player Vehicle #
		alias vehicle = allocate temporary object
		vehicle = current_player.vehicle
		-- # Get Player Vehicle #


		topMiddleWidget.set_visibility(current_player, true)
		bottomMiddleWidget.set_visibility(current_player, true)
		topLeftWidget.set_visibility(current_player, true)
		bottomLeftWidget.set_visibility(current_player, true)


		-- # Update Fuel UI #
		if maxFuel != -1 and vehicle.has_forge_label("Vehicle") then
			bottomMiddleWidget.set_meter_params(number, hud_player.currentFuelLevel, globalStorage.maxFuelLevel)
		end
		-- # Update Fuel UI #


		topMiddleWidget.set_text("%n KPH\n  P %n", hud_player.vehicleSpeedKPH, hud_player.position)
		bottomMiddleWidget.set_text("%n.%n", hud_player.currentLapSeconds, hud_player.currentLapMilliseconds)


		-- # We don't need to show dashStatus 1 or 2 if it is a single person lobby #
		if dashStatus == 1 or dashStatus == 2 then
			if numberOfPlayers == 1 then
				dashStatus = 0
			end
		end
		-- # We don't need to show dashStatus 1 or 2 if it is a single person lobby #


		if dashStatus == 0 then
			current_player.widget11 = bestLapSeconds
			current_player.widget12 = bestLapMilliseconds
			topLeftWidget.set_value_text("Fastest Lap: %n.%n", hud_player.widget11, hud_player.widget12)
			current_player.widget21 = storage.optimalLapSeconds
			current_player.widget22 = storage.optimalLapMilliseconds
			bottomLeftWidget.set_value_text("Optimal Lap: %n.%n", hud_player.widget21,hud_player.widget22)
		end
		if dashStatus == 1 then
			topLeftWidget.set_value_text("Fastest Lap: %p\nLap %n", bestLapPlayer, bestLapNumber)
			current_player.widget21 = current_player.bestLapSeconds
			current_player.widget22 = current_player.bestLapMilliseconds
			bottomLeftWidget.set_value_text("Personal Best: %n.%n", hud_player.widget21,hud_player.widget22)
		end
		if dashStatus == 2 then
			alias playerAhead = allocate temporary player
			playerAhead = current_player.playerAhead

			if storage.lapsAhead == 0 then
				current_player.widget11 = 0
				current_player.widget12 = 0
				if playerAhead != no_player then
					current_player.widget11 = storage.gapAheadSeconds
					current_player.widget12 = storage.gapAheadMilliseconds
				end
				topLeftWidget.set_value_text("Gap Ahead: %n.%n", hud_player.widget11, hud_player.widget12)
			end

			if storage.lapsAhead >= 1 then
				current_player.widget11 = storage.lapsAhead
				topLeftWidget.set_value_text("Gap Ahead: %n Lap(s)", hud_player.widget11)
			end

			alias playerBehind = allocate temporary player
			playerBehind = current_player.playerBehind

			if storage.lapsBehind == 0 then
				current_player.widget21 = 0
				current_player.widget22 = 0
				if playerBehind != no_player then
					current_player.widget21 = storage.gapBehindSeconds
					current_player.widget22 = storage.gapBehindMilliseconds
				end
				bottomLeftWidget.set_value_text("Gap Behind: %n.%n", hud_player.widget21, hud_player.widget22)
			end

			if storage.lapsBehind >= 1 then
				current_player.widget21 = storage.lapsBehind
				bottomLeftWidget.set_value_text("Gap Behind: %n Lap(s)", hud_player.widget21)
			end

		end

	end
	-- # Don't display UI if race has started and the Player is on a mongoose #

end
-- # Handle UI #



-- # Handle Checkpoints #
for each player do

	-- # Get Player Timing Object #
	alias timing = allocate temporary object
	timing = current_player.timing
	-- # Get Player Timing Object #


	-- # Get Player Storage Object #
	alias storage = allocate temporary object
	storage = current_player.storage
	-- # Get Player Storage Object #


	-- # Get players current Vehicle #
	alias vehicle = allocate temporary object
	vehicle = no_object
	vehicle = current_player.get_vehicle()
	-- # Get players current Vehicle #


	if current_player.score == 0 and timing.currentCheckpoint == 0 then
		storage.lapInvalidated = 1
		storage.sectorInvalidated = 1
	end


	-- # Compatibility for old maps without pit lane setups #
	if globalStorage.pitLaneConfigured == 0 and storage.pittedThisLap > 0 then
		storage.lapInvalidated = 1
	end
	-- # Compatibility for old maps without pit lane setups #


	-- # If the player is on a vehicle #
	if current_player.onVehicle == 1 then

		if timing.currentCheckpoint < firstCheckpoint.order or timing.currentCheckpoint > finalCheckpoint.order then
			timing.currentCheckpoint = firstCheckpoint.order
		end


		-- # Handle Jokers #
		if requiredJokers > 0 then
			for each object with label "joker" do
				if storage.jokeredThisLap == 1 or current_object.order != timing.currentCheckpoint or timing.jokerCount >= requiredJokers	then
					current_object.set_waypoint_visibility(mod_player, current_player, 0)
					current_object.set_shape_visibility(mod_player, current_player, 0)
				end

				if raceStatus >= 2 and timing.jokerCount < requiredJokers and storage.jokeredThisLap == 0 and current_object.spawn_sequence == timing.currentCheckpoint then

                    if waypointVisibility >= 1 then
						current_object.set_waypoint_visibility(mod_player, current_player, 1)
                    end
                    if waypointVisibility >= 2 then
						current_object.set_waypoint_icon(crown)
						current_object.set_shape_visibility(mod_player, current_player, 1)
                    end
                    if waypointVisibility >= 3 then
                        current_object.team = team[3]
                    end

					if current_object.shape_contains(current_player.biped) then
						timing.jokerCount += 1
						storage.jokeredThisLap = 1
						game.show_message_to(current_player, none, "You have completed %n/%n jokers", timing.jokerCount, requiredJokers )
					end
				end
			end
		end
		-- # Handle Jokers #


		for each object with label "race_flag" do
			current_object.set_waypoint_visibility(mod_player, current_player, 0)
			current_object.set_shape_visibility(mod_player, current_player, 0)

			if current_object.order == timing.currentCheckpoint then-- If checkpoint is the players current checkpoint
                if waypointVisibility >= 1 then
                    current_object.set_waypoint_visibility(mod_player, current_player, 1)
                end
                if waypointVisibility >= 2 then
                    if current_object.order == finalCheckpoint.order then
                        current_object.set_waypoint_icon(vip)
                    end
                    current_object.set_shape_visibility(mod_player, current_player, 1)
                end


				-- # The player has hit the checkpoint #
				if current_object.shape_contains(current_player.biped) then-- If the player is currently inside the checkpoint

					-- # Holeshot Marker #
					if holeshotPlayer == no_player then
						holeshotPlayer = current_player
						if numberOfPlayers != 1 then
							for each player do
								game.show_message_to(current_player, none, "%p got the holeshot", holeshotPlayer )
							end
						end
					end
					-- # Holeshot Marker #


					-- # Player should spawn at this checkpoint after hitting it #
					timing.respawnObject = current_object
					-- # Player should spawn at this checkpoint after hitting it #


					-- # Handle Sector Times #
					if timing.sectorTimeFrames != 0 then
						alias sectorTimeFrames = allocate temporary number
						sectorTimeFrames = timing.sectorTimeFrames -- Sector start frame
						framesIn = sectorTimeFrames
						timeFromFrames()
						alias bestOverallSector = allocate temporary number
						bestOverallSector = 0
						alias bestPersonalSector = allocate temporary number
						bestPersonalSector = 0


						if current_object.sector == 1 then
							if storage.sectorInvalidated == 0 then
								if timing.bestSector1TimeFrames == 0 or timing.bestSector1TimeFrames > sectorTimeFrames then
									timing.bestSector1TimeFrames = sectorTimeFrames
									bestPersonalSector = 1
								end
								if current_object.bestSectorTimeFrames == 0 or current_object.bestSectorTimeFrames > sectorTimeFrames then
									current_object.bestSectorTimeFrames = sectorTimeFrames
									bestOverallSector = 1
								end
							end

							-- # Send Sector Complete Notifications #
							if bestOverallSector == 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Overall Best Sector 1 time! %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Overall Best Sector 1 time! %n.%n", secondsOut, millisecondsOut )
								end
							end
							if bestOverallSector != 1 and bestPersonalSector == 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Personal Best Sector 1 time! %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Personal Best Sector 1 time! %n.%n", secondsOut, millisecondsOut )
								end
							end
							if bestOverallSector != 1 and bestPersonalSector != 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Sector 1: %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Sector 1: %n.%n", secondsOut, millisecondsOut )
								end
							end
							-- # Send Sector Complete Notifications #
					        timing.sectorTimeFrames = 0 -- sectorStartFrame -- Set Frame number the user started the current sector on
					        storage.sectorInvalidated = 0
						end
						if current_object.sector == 2 then
							if storage.sectorInvalidated == 0 then
								if timing.bestSector2TimeFrames == 0 or timing.bestSector2TimeFrames > sectorTimeFrames then
									timing.bestSector2TimeFrames = sectorTimeFrames
									bestPersonalSector = 1
								end
								if current_object.bestSectorTimeFrames == 0 or current_object.bestSectorTimeFrames > sectorTimeFrames then
									current_object.bestSectorTimeFrames = sectorTimeFrames
									bestOverallSector = 1
								end
							end

							-- # Send Sector Complete Notifications #
							if bestOverallSector == 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Overall Best Sector 2 time! %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Overall Best Sector 2 time! %n.%n", secondsOut, millisecondsOut )
								end
							end
							if bestOverallSector != 1 and bestPersonalSector == 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Personal Best Sector 2 time! %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Personal Best Sector 2 time! %n.%n", secondsOut, millisecondsOut )
								end
							end
							if bestOverallSector != 1 and bestPersonalSector != 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Sector 2: %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Sector 2: %n.%n", secondsOut, millisecondsOut )
								end
							end
							-- # Send Sector Complete Notifications #
					        timing.sectorTimeFrames = 0 -- sectorStartFrame -- Set Frame number the user started the current sector on
					        storage.sectorInvalidated = 0
						end
						if current_object.sector == 3 then
							if storage.sectorInvalidated == 0 then
								if timing.bestSector3TimeFrames == 0 or timing.bestSector3TimeFrames > sectorTimeFrames then
									timing.bestSector3TimeFrames = sectorTimeFrames
									bestPersonalSector = 1
								end
								if current_object.bestSectorTimeFrames == 0 or current_object.bestSectorTimeFrames > sectorTimeFrames then
									current_object.bestSectorTimeFrames = sectorTimeFrames
									bestOverallSector = 1
								end
							end

							-- # Send Sector Complete Notifications #
							if bestOverallSector == 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Overall Best Sector 3 time! %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Overall Best Sector 3 time! %n.%n", secondsOut, millisecondsOut )
								end
							end
							if bestOverallSector != 1 and bestPersonalSector == 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Personal Best Sector 3 time! %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Personal Best Sector 3 time! %n.%n", secondsOut, millisecondsOut )
								end
							end
							if bestOverallSector != 1 and bestPersonalSector != 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Sector 3: %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Sector 3: %n.%n", secondsOut, millisecondsOut )
								end
							end
							-- # Send Sector Complete Notifications #
					        timing.sectorTimeFrames = 0 -- sectorStartFrame -- Set Frame number the user started the current sector on
					        storage.sectorInvalidated = 0
						end
					end
					-- # Handle Sector Times #


					-- # Update Optimal Laptime #
					framesIn = timing.bestSector1TimeFrames
					framesIn += timing.bestSector2TimeFrames
					framesIn += timing.bestSector3TimeFrames
					timeFromFrames()
					storage.optimalLapSeconds = secondsOut
					storage.optimalLapMilliseconds = millisecondsOut

					if globalStorage.sectorCount >= 1 and timing.bestSector1TimeFrames == 0 then
						storage.optimalLapSeconds = 0
						storage.optimalLapMilliseconds = 0
					end
					if globalStorage.sectorCount >= 2 and timing.bestSector2TimeFrames == 0 then
						storage.optimalLapSeconds = 0
						storage.optimalLapMilliseconds = 0
					end
					if globalStorage.sectorCount >= 3 and timing.bestSector3TimeFrames == 0 then
						storage.optimalLapSeconds = 0
						storage.optimalLapMilliseconds = 0
					end
					-- # Update Optimal Laptime #


		            -- # Set Shields #
		            if current_object.sector != 4 then
		                if storage.optimalLapSeconds != 0 or storage.optimalLapMilliseconds != 0 then
		                    alias bestLapFrames = allocate temporary number
		                    bestLapFrames = 0
		                    if current_object.sector >= 1 then
		                        bestLapFrames += vehicle.bestSector1TimeFrames
		                    end
		                    if current_object.sector >= 2 then
		                        bestLapFrames += vehicle.bestSector2TimeFrames
		                    end

		                    alias frameScale = allocate temporary number
		                    frameScale = bestLapFrames
		                    frameScale *= 225
		                    frameScale /= 10000

		                    current_player.money = timing.lapFrames
						    current_player.money -= bestLapFrames

		                    if current_player.money > 0 then
							    current_player.money *= 100
							    current_player.money /= frameScale
							    current_player.money += 300

							    if current_player.money > 400 then
								    current_player.money = 400
							    end
		                    end
		                    if current_player.money < 0 then
							    current_player.money *= -100
							    current_player.money /= frameScale
							    current_player.money += 100

							    if current_player.money > 200 then
								    current_player.money = 200
							    end
		                    end
		                    if current_player.money == 0 then
							    current_player.money = 300
		                    end
		                end
		            end
		            -- # Set Shields #


					-- # Find next checkpoint #
					alias nextCheckpointNumber = allocate temporary number
					nextCheckpointNumber = finalCheckpoint.order
					nextCheckpointNumber += 1 -- Number of maximum checkpoints + 1
					for each object with label "race_flag" do
						if current_object.order > timing.currentCheckpoint and current_object.order < nextCheckpointNumber then
							nextCheckpointNumber = current_object.order
						end
					end
					-- # Find next checkpoint #


					-- # Update Player Current Checkpoint #
					timing.currentCheckpoint = nextCheckpointNumber
					-- # Update Player Current Checkpoint #


					-- # Calculate Gaps #

					-- # If you are on the same lap as the player ahead of you #
					alias aheadPlayer = allocate temporary player
					aheadPlayer = current_player.playerAhead
					alias aheadTiming = allocate temporary object
					aheadTiming = aheadPlayer.timing
					alias aheadStorage = allocate temporary object
					aheadStorage = aheadPlayer.storage

					if aheadPlayer != no_player and storage.lapsAhead == 0 then
						alias sectorAhead = allocate temporary number
						alias currentSector = allocate temporary number

						for each object with label "race_flag" do
							if current_object.order <= aheadTiming.currentCheckpoint then
								if current_object.sector <= 3 and current_object.sector > sectorAhead then
									sectorAhead = current_object.sector
								end
							end
							if current_object.order <= timing.currentCheckpoint then
								if current_object.sector <= 3 and current_object.sector > currentSector then
									currentSector = current_object.sector
								end
							end
						end

						if currentSector == sectorAhead then
							framesIn = aheadTiming.sectorTimeFrames
							timeFromFrames()
							storage.gapAheadSeconds = secondsOut
							storage.gapAheadMilliseconds = millisecondsOut

							if secondsOut < 0 then
								secondsOut *= -1
							end
							if millisecondsOut < 0 then
								millisecondsOut *= -1
							end

							aheadStorage.gapBehindSeconds = secondsOut
							aheadStorage.gapBehindMilliseconds = millisecondsOut
						end
					end
					-- # If you are on the same lap as the player ahead of you #

					-- # Calculate Gaps #


					-- # Player has completed a lap #
					if timing.currentCheckpoint > finalCheckpoint.order then

						-- # Notify the user of how much fuel was used #
						if maxFuel != -1 and vehicle.has_forge_label("Vehicle") then
							if current_player.score == 0 and vehicle.lapStartingFuel == 0 then
								vehicle.lapStartingFuel = globalStorage.maxFuelLevel
							end

							if vehicle.lapStartingFuel != 0 then
								vehicle.fuelUsedLastLap = vehicle.lapStartingFuel
								vehicle.fuelUsedLastLap -= current_player.currentFuelLevel
								if vehicle.lapStartingFuel > current_player.currentFuelLevel then
									alias fuelMajor = allocate temporary number
									fuelMajor = vehicle.fuelUsedLastLap
									fuelMajor /= 1000
									fuelMajor *= 1000
									alias fuelMinor = allocate temporary number
									fuelMinor = vehicle.fuelUsedLastLap
									fuelMinor -= fuelMajor
									fuelMinor /= 100
									fuelMajor /= 1000
									game.show_message_to(current_player, none, "Fuel Used last lap %n.%n", fuelMajor, fuelMinor )
								end
							end
							vehicle.lapStartingFuel = current_player.currentFuelLevel
						end
						-- # Notify the user of how much fuel was used #


						if raceStatus >= 2 then

							-- # Calculate Gaps #

							-- # If you are on the same lap as the player ahead of you #
							alias aheadPlayer = allocate temporary player
							aheadPlayer = current_player.playerAhead
							alias aheadTiming = allocate temporary object
							aheadTiming = aheadPlayer.timing
							alias aheadStorage = allocate temporary object
							aheadStorage = aheadPlayer.storage

							if aheadPlayer != no_player and storage.lapsAhead == 0 then
								framesIn = aheadTiming.lapFrames
								timeFromFrames()
								storage.gapAheadSeconds = secondsOut
								storage.gapAheadMilliseconds = millisecondsOut
								aheadStorage.gapBehindSeconds = secondsOut
								aheadStorage.gapBehindMilliseconds = millisecondsOut
							end
							-- # If you are on the same lap as the player ahead of you #

							-- # Calculate Gaps #


							alias bestPersonalLap = allocate temporary number
							bestPersonalLap = 0
							alias bestOverallLap = allocate temporary number
							bestOverallLap = 0

							-- # Reset Player checkpoint counter #
							timing.currentCheckpoint = firstCheckpoint.order
							-- # Reset Player checkpoint counter #


							-- # Increment Player Score #
							current_player.score += 1
							-- # Increment Player Score #


							-- # Set Player Best Lap #
							if storage.lapInvalidated == 0 then
								--if current_player.score >= 2 and current_player.bestLapSeconds == 0 and current_player.bestLapMilliseconds == 0 then
								if current_player.bestLapSeconds == 0 and current_player.bestLapMilliseconds == 0 then
									bestPersonalLap = 1
									current_player.bestLapSeconds = current_player.currentLapSeconds
									current_player.bestLapMilliseconds = current_player.currentLapMilliseconds
									current_player.bestLapNumber = current_player.score
								end
								if current_player.currentLapSeconds < current_player.bestLapSeconds then
									bestPersonalLap = 1
									current_player.bestLapSeconds = current_player.currentLapSeconds
									current_player.bestLapMilliseconds = current_player.currentLapMilliseconds
									current_player.bestLapNumber = current_player.score
								end
								if current_player.currentLapSeconds == current_player.bestLapSeconds and current_player.currentLapMilliseconds < current_player.bestLapMilliseconds then
									bestPersonalLap = 1
									current_player.bestLapSeconds = current_player.currentLapSeconds
									current_player.bestLapMilliseconds = current_player.currentLapMilliseconds
									current_player.bestLapNumber = current_player.score
								end
							end
							-- # Set Player Best Lap #


							-- # Set Fastest Laptime #
							if storage.lapInvalidated == 0 then
								--if current_player.score >= 2 and bestLapSeconds == 0 and bestLapMilliseconds == 0 then
								if bestLapSeconds == 0 and bestLapMilliseconds == 0 then
									bestOverallLap = 1
									bestLapSeconds = current_player.currentLapSeconds
									bestLapMilliseconds = current_player.currentLapMilliseconds
									bestLapPlayer = current_player
									bestLapNumber = current_player.score
								end
								if current_player.currentLapSeconds < bestLapSeconds then
									bestOverallLap = 1
									bestLapSeconds = current_player.currentLapSeconds
									bestLapMilliseconds = current_player.currentLapMilliseconds
									bestLapPlayer = current_player
									bestLapNumber = current_player.score
								end
								if current_player.currentLapSeconds == bestLapSeconds and current_player.currentLapMilliseconds < bestLapMilliseconds then
									bestOverallLap = 1
									bestLapSeconds = current_player.currentLapSeconds
									bestLapMilliseconds = current_player.currentLapMilliseconds
									bestLapPlayer = current_player
									bestLapNumber = current_player.score
								end
							end
							-- # Set Fastest Laptime #


							-- # Send Lap Complete Notifications #
							if bestOverallLap == 1 and storage.lapInvalidated == 0 then
								if current_player.currentLapMilliseconds >= 100 then
									game.show_message_to(current_player, none, "Overall Best lap time! %n.%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
								if current_player.currentLapMilliseconds < 100 then
									game.show_message_to(current_player, none, "Overall Best lap time! %n.0%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
							end
							if bestOverallLap != 1 and bestPersonalLap == 1 and storage.lapInvalidated == 0 then
								if current_player.currentLapMilliseconds >= 100 then
									game.show_message_to(current_player, none, "Personal Best lap time! %n.%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
								if current_player.currentLapMilliseconds < 100 then
									game.show_message_to(current_player, none, "Personal Best lap time! %n.0%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
							end
							if bestOverallLap != 1 and bestPersonalLap != 1 then
								if current_player.currentLapMilliseconds >= 100 then
									game.show_message_to(current_player, none, "Lap Complete: %n.%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
								if current_player.currentLapMilliseconds < 100 then
									game.show_message_to(current_player, none, "Lap Complete: %n.0%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
							end
							send_incident(lap_complete, current_player, no_player)
							-- # Send Lap Complete Notifications #


							-- # Subtract from pit status -1 #
							storage.pittedThisLap -= 1
							-- # Subtract from pit status -1 #


							-- # Notify everyone of the final lap #
							do
								alias whiteFlagLap = allocate temporary number
								whiteFlagLap = numberOfLaps -- # Number of laps
								whiteFlagLap -= 1
								if current_player.score == whiteFlagLap then
									alias scoreboardPosition = allocate temporary number
									scoreboardPosition = 0
									scoreboardPosition = current_player.get_scoreboard_pos()
									if scoreboardPosition == 1 then
										send_incident(final_lap, current_player, all_players)
									end
								end
							end
							-- # Notify everyone of the final lap #


							-- # Update Vehicle Cached Time Frames #
							vehicle.bestSector1TimeFrames = timing.bestSector1TimeFrames
							vehicle.bestSector2TimeFrames = timing.bestSector2TimeFrames
							-- # Update Vehicle Cached Time Frames #


						    current_player.money = 100
							storage.lapInvalidated = 0
							storage.jokeredThisLap = 0 -- Reset joker flag
							timing.lapFrames = 1 -- lapFrames -- Reset lap frame count
						end
					end
					-- # Player has completed a lap #


					-- # Start the race when someone hits a checkpoint #
					if raceStatus < 2 then
						raceStatus = 2
						timing.lapFrames = 1 -- lapFrames
						frames = 0
					end
					-- # Start the race when someone hits a checkpoint #


				end
				-- # The player has hit the checkpoint #

			end
		end
	end
	-- # If the player is on a vehicle #
end
-- # Handle Checkpoints #



-- # Handle Fuel #
if maxFuel != -1 then

	-- # Associate pitbox with player #
	for each object with label "pit_stop" do
		current_object.set_waypoint_range(0, 15)
        current_object.set_waypoint_icon(none)

        if waypointVisibility >= 3 then
            current_object.set_waypoint_text("Pit Box")
        end

		alias found = allocate temporary number
		found = 0
		for each player do
			if current_player.vehicle.has_forge_label("Vehicle") then
			    if current_player.pitbox == 999 or current_player.pitbox == current_object.spawn_sequence then
				    if numberOfPlayers > 8 or current_object.spawn_sequence <= 8 or current_player.pitbox == current_object.spawn_sequence then
				        if waypointVisibility >= 1 then
					        current_object.set_waypoint_visibility(mod_player, current_player, 1)
				        end
                        if waypointVisibility >= 2 then
					        current_object.set_waypoint_visibility(mod_player, current_player, 1)
					        current_object.set_shape_visibility(mod_player, current_player, 1)
				        end
				    end
			    end
			    if current_player.pitbox != 999 and current_player.pitbox != current_object.spawn_sequence then
				    current_object.set_waypoint_visibility(mod_player, current_player, 0)
				    current_object.set_shape_visibility(mod_player, current_player, 0)
			    end

			    if current_object.shape_contains( current_player.biped ) and current_player.pitbox == 999 then
				    if current_object.registrationTimer < 200 then
					    current_object.registrationTimer += 1
					    found = 1
				    end
				    if current_object.registrationTimer >= 200 then
					    current_player.pitbox = current_object.spawn_sequence
					    current_object.registrationTimer = 0
				    end
			    end
		    end
		end
		if found == 0 then
			current_object.registrationTimer = 0
		end
	end
	-- # Associate pitbox with player #


	if raceStatus >= 2 then

		alias debounce = allocate temporary number
		alias temp = allocate temporary number
		temp = frames
		temp /= 20
		temp *= 20
		debounce = frames
		debounce -= temp


		if debounce == 0 then -- run 3 times a second

			-- # Enforce Pit Speed Limits #
			for each player do
                alias timing = allocate temporary object
                timing = current_player.timing
                alias storage = allocate temporary object
                storage = current_player.storage
	            alias vehicle = allocate temporary object
	            vehicle = current_player.vehicle
	            alias inPitLane = allocate temporary number
	            inPitLane = 0

				for each object with label "speed_limit" do
					current_object.set_shape_visibility(mod_player, current_player, 0)

					if current_player.onVehicle == 1 and current_object.shape_contains( current_player.biped ) then
						inPitLane = 1
			            storage.lapInvalidated = 1
			            storage.sectorInvalidated = 1
			            if waypointVisibility >= 2 then
				            current_object.set_shape_visibility(mod_player, current_player, 1)
			            end
					end
				end

				if inPitLane == 1 then
                    if current_player.vehicleSpeedKPH > 40 then
                        if vehicle.speedWarnings >= 12 then
                            timing.penalty += 300
                            vehicle.speedWarnings = 0
                            game.show_message_to(current_player, none, "You have earned yourself a 5s penalty bud" )
                        end
                        if vehicle.speedWarnings < 12 then
                            vehicle.speedWarnings += 3
                            game.show_message_to(current_player, none, "Slow down to 40kph or you will get a penalty" )
                        end
                    end
                    if current_player.vehicleSpeedKPH <= 40 and vehicle.speedWarnings > 0 then
                        vehicle.speedWarnings -= 1
                    end
                    if vehicle.speedWarnings <= 0 then
                        vehicle.speedWarnings = 0
                    end
				end

				if inPitLane == 0 then
                    if current_player.vehicleSpeedKPH <= 40 then
                        vehicle.speedWarnings -= 1
                    end
                    if vehicle.speedWarnings <= 0 then
                        vehicle.speedWarnings = 0
                    end
				end

                if current_player.onVehicle == 0 then
                    vehicle.speedWarnings = 0
                end
			end
			-- # Enforce Pit Speed Limits #


			-- # Calculate Drafts #
			for each player do
				alias vehicle = allocate temporary object
				vehicle = no_object
				vehicle = current_player.get_vehicle()
				vehicle.draftBonus = 0
			end
			if draft != -1 then
				for each player do
					alias originalPlayer = allocate temporary player
					originalPlayer = current_player
					alias originalPlayerTiming = allocate temporary object
					originalPlayerTiming = originalPlayer.timing
					originalPlayerTiming.detach()

					for each player do
						if originalPlayer != current_player then
							alias distance = allocate temporary number
							distance = 0
							distance = current_player.biped.get_distance_to(originalPlayer.timing)
							alias distance2 = allocate temporary number
							distance2 = 0
							distance2 = current_player.biped.get_distance_to(originalPlayer.biped)
							distance -= distance2
					        alias currentPlayerTiming = allocate temporary object
					        currentPlayerTiming = current_player.timing

							if current_player.vehicleSpeedKPH > 55 and originalPlayer.vehicleSpeedKPH > 55 and distance >= 8 then
								currentPlayerTiming.detach()
								distance = originalPlayer.biped.get_distance_to(current_player.timing)
								alias distance3 = allocate temporary number
								distance3 = 0
								distance3 = originalPlayer.biped.get_distance_to(current_player.biped)

								if distance < distance3 then
									alias vehicle = allocate temporary object
									vehicle = no_object
									vehicle = current_player.get_vehicle()

									if distance2 < 150 then
										vehicle.draftBonus = 150
										vehicle.draftBonus -= distance2
										vehicle.draftBonus *= 100
										vehicle.draftBonus /= 150

										vehicle.draftBonus *= 50
										vehicle.draftBonus *= draft
										vehicle.draftBonus /= 10000

										vehicle.draftBonus *= originalPlayer.vehicleSpeedKPH
										vehicle.draftBonus /= 100

										vehicle.draftBonus *= current_player.vehicleSpeedKPH
										vehicle.draftBonus /= 100
									end
								end
							end
								currentPlayerTiming.draftObject.attach_to(current_player.biped, 10, 0, 0, relative)
						end
					end

					originalPlayerTiming.attach_to(current_player.biped, 10, 0, 0, relative)
				end
			end
			-- # Calculate Drafts #


			for each player do

				-- # Get players current Vehicle #
				alias vehicle = allocate temporary object
				vehicle = no_object
				vehicle = current_player.get_vehicle()
				-- # Get players current Vehicle #


				if vehicle.has_forge_label("Vehicle") then

				    -- # Get Player Timing Object #
				    alias timing = allocate temporary object
				    timing = current_player.timing
				    -- # Get Player Timing Object #


				    -- # Get Player Storage Object #
				    alias storage = allocate temporary object
				    storage = current_player.storage
				    -- # Get Player Storage Object #


				    -- # Initialize Fuel #
				    if current_player.currentFuelLevel == -30000 then				-- -30000 is a magic number to indicate that the player has never had fuel before

					    -- # Set Max Fuel Level #
					    if globalStorage.maxFuelLevel == 0 then
						    globalStorage.maxFuelLevel = 5000								-- Set the Base fuel level
						    globalStorage.maxFuelLevel *= 60								-- Scale Base fuel level up to a useable value with a magic number
						    globalStorage.maxFuelLevel *= maxFuel							-- Max Fuel is a percentage of fuel selected in the gametype
						    globalStorage.maxFuelLevel /= 100								-- Convert Max Fuel to a percentage
					    end
					    -- # Set Max Fuel Level #

					    current_player.currentFuelLevel = globalStorage.maxFuelLevel		-- Set the players currentFuelLevel to the maxFuelLevel
					    -- # Set Max Fuel Level #
				    end
				    -- # Initialize Fuel #


				    -- # Initialize Refuel Amount #
				    if vehicle.refuelAmount == 0 then
					    vehicle.refuelAmount = globalStorage.maxFuelLevel					-- Start with our max fuel level
					    vehicle.refuelAmount /= 3									-- Divide it by 3 because we run this update code 3x per second
					    vehicle.refuelAmount /= refuelRate							-- Divide it by the desired pit stop length selected in the gametype options
				    end
				    -- # Initialize Refuel Amount #


				    -- # Teleport to pitbox or remove Player from Vehicle if they have no fuel #
				    if current_player.currentFuelLevel <= 0 and current_player.currentFuelLevel != -30000 then
					    alias selectedPitbox = allocate temporary object
					    selectedPitbox = no_object

					    for each object with label "pit_stop" do
						    if selectedPitbox == no_object then
						        if current_player.pitbox == 999 then
							        if current_object.player[0] == no_player then
								        selectedPitbox = current_object
							        end
						        end

						        if current_player.pitbox == current_object.spawn_sequence then
							        selectedPitbox = current_object
						        end
						    end
					    end

					    if selectedPitbox != no_object then
                            current_player.vehicle.attach_to(selectedPitbox, 0, 0, 2, relative)
                            current_player.vehicle.detach()
                            current_player.vehicle.copy_rotation_from(selectedPitbox, false)
                            current_player.currentFuelLevel = 500

                            if timing.currentCheckpoint == finalCheckpoint.order then
                                timing.currentCheckpoint = firstCheckpoint.order
                            end
					    end

					    if selectedPitbox == no_object then
					        current_player.biped.detach()
					        current_player.onVehicle = 0
					        current_player.vehicle.delete()
					    end

				    end
				    -- # Teleport to pitbox or remove Player from Vehicle if they have no fuel #


				    if current_player.onVehicle == 1 and current_player.currentFuelLevel > 0 and current_player.biped != no_object then
					    alias fueling = allocate temporary number
					    fueling = 0

					    -- # Update Vehicle Fuel #
					    do
						    alias fuelUsage = allocate temporary number
						    fuelUsage = 100												-- Base fuel usage

						    alias fuelCalc = allocate temporary number
						    fuelCalc = current_player.vehicleSpeedKPH					-- Start the fuel calculation with the vehicles current speed
						    fuelCalc -= vehicle.startingFuelSpeed						-- Subtract the vehicles speed from three tenths of a second ago
						    fuelCalc *= 30												-- Multiply by a magic number to scale this up to a useable value

						    fuelUsage += fuelCalc										-- Add the rate of change fuel calculation to the base fuel usage


						    if vehicle.draftBonus > 0 then
							    fuelUsage -= vehicle.draftBonus
						    end

						    if vehicle.startingFuelSpeed > 55 and current_player.vehicleSpeedKPH > 55 and vehicle.startingFuelSpeed <= current_player.vehicleSpeedKPH then -- 55kmh being roughly the speed that we shift to 2nd
							    fuelUsage -= 28											-- Fuel efficiency slightly better in 2nd gear
						    end

						    if vehicle.startingFuelSpeed == 0 and current_player.vehicleSpeedKPH == 0 or fuelUsage < 5 then
							    fuelUsage = 5											-- Idle fuel usage
						    end


						    current_player.currentFuelLevel -= fuelUsage				-- Subtract the fuel usage calculation from the users current fuel level
						    vehicle.startingFuelSpeed = current_player.vehicleSpeedKPH	-- Store the vehicles current speed for the next time we run this calculation
					    end
					    -- # Update Vehicle Fuel #


					    -- # Refuel Vehicles that are parked on a Pit Box #
					    for each object with label "pit_stop" do
						    if current_player.vehicleSpeedKPH <= 5 and current_object.shape_contains( vehicle ) and current_player.currentFuelLevel < globalStorage.maxFuelLevel then
							    if current_player.pitbox == 999 or current_player.pitbox == current_object.spawn_sequence then
								    if timing.penalty > 0 then
									    alias notify = allocate temporary number
									    notify = timing.penalty
									    notify /= 60
									    notify *= 60

									    if timing.penalty == notify then
										    notify /= 60
										    game.show_message_to(current_player, none, "Serving Time Penalty %ns", notify )
									    end
									    timing.penalty -= 20
									    current_player.currentFuelLevel += 5 -- Give them the idle fuel back to make sure they don't die while serving a penalty
								    end

								    if current_player.currentFuelLevel < globalStorage.maxFuelLevel and timing.penalty <= 0 then
									     storage.pittedThisLap = 2 --	# Set Pit Status #
									     storage.sectorInvalidated = 1
									     alias maximumRefuelAmount = allocate temporary number
									     maximumRefuelAmount = globalStorage.maxFuelLevel
									     maximumRefuelAmount -= current_player.currentFuelLevel
									     alias refuelAmount = allocate temporary number
									     refuelAmount = vehicle.refuelAmount

									     if refuelAmount > maximumRefuelAmount then
									        refuelAmount = maximumRefuelAmount
									     end

									     current_player.currentFuelLevel += refuelAmount
									     vehicle.fuelTaken += refuelAmount

									     if current_player.currentFuelLevel > globalStorage.maxFuelLevel then
										     current_player.currentFuelLevel = globalStorage.maxFuelLevel
									     end
									     fueling = 1
								    end
							    end
						    end

					    end
					    -- # Refuel Vehicles that are parked on a Pit Box #


					    -- # Alert the racer how much fuel they refilled #
					    if fueling == 0 then
						    if vehicle.fuelTaken > 1000 then
	                            alias fuelMajor = allocate temporary number
	                            fuelMajor = vehicle.fuelTaken
	                            fuelMajor /= 1000
	                            fuelMajor *= 1000
	                            alias fuelMinor = allocate temporary number
	                            fuelMinor = vehicle.fuelTaken
	                            fuelMinor -= fuelMajor
	                            fuelMinor /= 100
	                            fuelMajor /= 1000
							    game.show_message_to(current_player, none, "Amount of fuel refilled %n.%n", fuelMajor, fuelMinor )
						    end
						    vehicle.fuelTaken = 0
					    end
					    -- # Alert the racer how much fuel they refilled #

					end
				end

			end
		end

	end
end
-- # Handle Fuel #



on local: do
	if host == 0 then


		--	# Hide Invisible Race Objects #
		for each object with label "race_hide" do
			current_object.set_hidden(true)
		end
		--	# Hide Invisible Race Objects #


		-- # Hide Race Gates #
		if startGate != 0 then
			alias localStartGateFrame = allocate temporary number
			localStartGateFrame = globalStorage.startGateFrame
			localStartGateFrame -= 6 -- How much earlier should the gates visually disappear before they physically disappear
			if raceStatus == 1 and globalStorage.startGateDropped == 0 and frames > localStartGateFrame and globalStorage.waitForGridSpots == 0 then
				for each object with label "race_gate" do
					current_object.set_hidden(true)
				end
			end
		end
		-- # Hide Race Gates #


		-- # Detect Client Player --
		for each object with label "target" do
			current_object.delete()
		end
		if client == no_player	then
			for each player do
				current_player.biped.detach()
				alias weapon = allocate temporary object
				weapon = current_player.try_get_weapon(primary)
				alias target = allocate temporary object
				target = weapon.place_at_me(monitor, "target", suppress_effect, 3, 1, 1, none)
				target.attach_to(weapon, 3, 1, 1, relative)
				target.detach()
				alias get = allocate temporary object
				get = current_player.get_crosshair_target()
				if get != no_object then
					client = current_player
				end
			end
		end
		-- # Detect Client Player --


		if raceStatus >= 2 then

			-- # Get players current Vehicle #
			alias vehicle = allocate temporary object
			vehicle = no_object
			vehicle = client.get_vehicle()
			-- # Get players current Vehicle #


			-- # Get Player Timing Object #
			alias timing = allocate temporary object
			timing = client.timing
			-- # Get Player Timing Object #


			-- # Set Current Local Lap time #
			localCurrentLapSeconds = localLapFrames
			localCurrentLapSeconds /= 60
			alias t = allocate temporary number
			t = localCurrentLapSeconds
			t *= 60
			localCurrentLapMilliseconds = localLapFrames
			localCurrentLapMilliseconds -= t
			localCurrentLapMilliseconds *= 1000
			localCurrentLapMilliseconds /= 60
			-- # Set Current Local Lap time #


			-- # Display the players current lap time #
			if localCurrentLapMilliseconds >= 100 then
				bottomMiddleWidget.set_text("%n.%n", localCurrentLapSeconds, localCurrentLapMilliseconds )
			end
			if localCurrentLapMilliseconds < 100 then
				bottomMiddleWidget.set_text("%n.0%n", localCurrentLapSeconds, localCurrentLapMilliseconds )
			end
			-- # Display the players current lap time #


			-- # Increment the player frame counters #
			localLapFrames += 1 -- lapFrames
			-- # Increment the player frame counters #


			-- # Player has completed a lap #
			if localLapFrames > 15 and client.onVehicle == 1 then
				for each object with label "race_flag" do
					if current_object.order == timing.currentCheckpoint and timing.currentCheckpoint == finalCheckpoint.order then
						if current_object.shape_contains(client.biped) then
							localLapFrames = 0
						end
					end
				end
			end
			-- # Player has completed a lap #


			-- # Update Vehicle Speed #
			client.vehicleSpeedKPH = 0
			if client.onVehicle == 1 and client.biped != no_object then
				client.vehicleSpeedKPH = client.biped.get_speed()
				client.vehicleSpeedKPH *= 109 -- Convert from Feet Per Second to KPH
				client.vehicleSpeedKPH /= 100 -- Convert from Feet Per Second to KPH

				if client.vehicleSpeedKPH < 0 then
					client.vehicleSpeedKPH = 0
				end
				if client.vehicleSpeedKPH > 200 then
					client.vehicleSpeedKPH = 200
				end
			end
			-- # Update Vehicle Speed #

		end


	end
end



on host migration: do


		--	# Hide Invisible Race Objects #
		for each object with label "race_hide" do
			current_object.set_hidden(true)
		end
		--	# Hide Invisible Race Objects #



		-- # Delete Race Gates #
		for each object with label "race_gate" do
			current_object.delete()
		end
		-- # Delete Race Gates #



end