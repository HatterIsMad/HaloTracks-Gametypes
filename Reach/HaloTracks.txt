-- /* GLOBAL VARIABLES */

alias	bestLapSeconds					= global.number[0]
alias	bestLapMilliseconds				= global.number[1]
alias	bestLapNumber					= global.number[2]
alias	frames							= global.number[3]
alias	framesOverflow					= global.number[4]
alias	host							= global.number[5]
alias	localCurrentLapSeconds			= global.number[6]
alias	localCurrentLapMilliseconds		= global.number[7]
alias	localLapFrames					= global.number[8]
alias	numberOfPlayers					= global.number[9]

alias	dashStatus						= global.number[10]
-- dashStatus = 0 -- Show Dash page 1
-- dashStatus = 1 -- Show Dash page 2
-- dashStatus = 2 -- Show Dash page 3
-- dashStatus = 3 -- Unused
-- dashStatus = 4 -- Show Post Race Dash

alias	raceStatus						= global.number[11]
-- raceStatus = 0 -- Game is starting, we haven't spawned yet
-- raceStatus = 1 -- Gridding has started
-- raceStatus = 2 -- Race has started
-- raceStatus = 3 -- Race time period has ended
-- raceStatus = 4 -- Race has ended

declare	bestLapSeconds					with network priority high
declare	bestLapMilliseconds				with network priority high
declare	bestLapNumber					with network priority high
declare	frames							with network priority high	= 0
declare	framesOverflow					with network priority high	= 1
declare	host							with network priority local	= 0
declare	localCurrentLapSeconds			with network priority local	= 0
declare	localCurrentLapMilliseconds		with network priority local	= 0
declare	dashStatus						with network priority local	= 0
declare	raceStatus						with network priority high	= 0


alias	bestLapPlayer					= global.player[0]
alias	client							= global.player[1]
alias	holeshotPlayer					= global.player[2]
declare bestLapPlayer					with network priority high
declare client							with network priority local
declare holeshotPlayer					with network priority local


alias	finalCheckpoint					= global.object[0]
alias	firstCheckpoint					= global.object[1]
alias	globalStorage					= global.object[2]

-- /* GLOBAL VARIABLES */



-- /* SCRIPT OPTIONS */

alias	numberOfLaps					= script_option[0]
alias	maxFuel							= script_option[1]
alias	refuelRate						= script_option[2]
alias	invincibility					= script_option[3]
alias	cvDelete						= script_option[4]
alias	requiredJokers					= script_option[5]
alias	lowPriorityWaypoints			= script_option[6]
alias	startGate						= script_option[7]
alias	defaultVehicle					= script_option[8]

-- /* SCRIPT OPTIONS */



-- /* PLAYER VARIABLES */

alias	position						= player.number[0]
alias	vehicleSpeedKPH					= player.number[1]
alias	currentFuelLevel				= player.number[2]
alias	currentLapMilliseconds			= player.number[3]
alias	widget21						= player.number[4]
alias	widget22						= player.number[5]
alias	widget11						= player.number[6]
alias	widget12						= player.number[7]
alias	vehicleRespawnTimer				= player.timer[0]
alias	onVehicle						= player.timer[1]
alias	offTrackDebounce				= player.timer[2]
alias	pitbox							= player.timer[3]

declare	player.position					with network priority high	= 1
declare	player.currentFuelLevel			with network priority high	= -30000
declare	player.vehicleSpeedKPH			with network priority local
declare	player.currentLapMilliseconds	with network priority local


declare	player.vehicleRespawnTimer		= 7
declare	player.pitbox					= 999


alias	vehicle							= player.object[0]
alias	timing							= player.object[1]
alias	storage							= player.object[2]

alias	playerAhead						= player.player[0]
alias	playerBehind					= player.player[1]


alias	bestLapSeconds					= player.script_stat[0]
alias	bestLapMilliseconds				= player.script_stat[1]
alias	bestLapNumber					= player.script_stat[2]
alias	currentLapSeconds				= player.script_stat[3]

-- /* PLAYER VARIABLES */



-- /* OBJECT VARIABLES */


	-- /* Player Timing Object */
	alias	jokerCount						= object.number[0]
	alias	sectorTimeFrames				= object.number[1]
	alias	lapFrames						= object.number[2]
	alias	offTrackCount					= object.number[3]
	alias	penalty							= object.number[4]
	alias	bestSector1TimeFrames			= object.timer[0]
	alias	bestSector2TimeFrames			= object.timer[1]
	alias	bestSector3TimeFrames			= object.timer[2]
	alias	currentCheckpoint				= object.timer[3]
	-- /* Player Timing Object */


	-- /* Player Storage Object */
	alias	lapsAhead						= object.number[0]
	alias	lapsBehind						= object.number[1]
	alias	gapAheadSeconds					= object.number[2]
	alias	gapAheadMilliseconds			= object.number[3]
	alias	gapBehindSeconds				= object.number[4]
	alias	gapBehindMilliseconds			= object.number[5]
	alias	optimalLapSeconds				= object.number[6]
	alias	optimalLapMilliseconds			= object.number[7]
	alias	jokeredThisLap					= object.timer[0]
	alias	pittedThisLap					= object.timer[1]
	alias	sectorInvalidated				= object.timer[2]
	alias	lapInvalidated					= object.timer[3]
	-- /* Player Storage Object */


	-- /* Vehicle Object */
	alias	startingFuelSpeed				= object.number[0]
	alias	lapStartingFuel					= object.number[1]
	alias	fuelUsedLastLap					= object.number[2]
	alias	refuelAmount					= object.number[3]
	alias	fuelTaken						= object.number[4]
	-- /* Vehicle Object */


	-- /* Checkpoint Object */
	alias	order							= object.number[0]
	-- /* Checkpoint Object */


	-- /* Global Storage Object */
	alias	maxFuelLevel					= object.number[0]
	alias	startGateFrame					= object.number[1]
	alias	startGateDropped				= object.number[2]
	alias	sectorCount						= object.number[3]
	-- /* Global Storage Object */


-- /* OBJECT VARIABLES */



-- /* HUD WIDGETS */

alias	topMiddleWidget					= script_widget[0]
alias	bottomMiddleWidget				= script_widget[1]
alias	topLeftWidget					= script_widget[2]
alias	bottomLeftWidget				= script_widget[3]

-- /* HUD WIDGETS */





-- # Functions #


alias framesIn = allocate temporary number
alias secondsOut = allocate temporary number
alias millisecondsOut = allocate temporary number
function timeFromFrames()
	secondsOut = framesIn
	secondsOut /= 60

	alias t = allocate temporary number
	t = secondsOut
	t *= 60

	millisecondsOut = framesIn
	millisecondsOut -= t
	millisecondsOut *= 1000
	millisecondsOut /= 60
end


-- # Functions #




-- # Initialize #

on init: do


	-- # Initialize Checkpoints #
	for each object with label "race_flag" do
		alias checkpoint = allocate temporary object
		checkpoint = current_object
		checkpoint.order = checkpoint.spawn_sequence
		checkpoint.team = neutral_team
		checkpoint.set_waypoint_icon(none)
		checkpoint.set_waypoint_priority(normal)
		if lowPriorityWaypoints == 1 then
			checkpoint.set_waypoint_priority(low)
		end
		checkpoint.set_invincibility(1)
		checkpoint.set_spawn_location_permissions(no_one)

		if finalCheckpoint == no_object or checkpoint.order > finalCheckpoint.order then
			finalCheckpoint = checkpoint
		end

		if firstCheckpoint == no_object or checkpoint.order < firstCheckpoint.order then
			firstCheckpoint = checkpoint
		end

	end
	-- # Initialize Checkpoints #


	-- # Figure out Checkpoint Sectors #
	do

		alias sector1 = allocate temporary object
		sector1 = no_object
		for each object with label "race_flag" do
			if sector1 == no_object or sector1.order > current_object.order then
				sector1 = current_object
				globalStorage.sectorCount += 1
			end
		end

		alias sector2 = allocate temporary object
		sector2 = no_object
		if sector1 != no_object then
			for each object with label "race_flag" do
				if current_object.order > sector1.order then
					if sector2 == no_object or sector2.order > current_object.order then
						sector2 = current_object
						globalStorage.sectorCount += 1
					end
				end
			end
		end

		alias sector3 = allocate temporary object
		sector3 = no_object
		if sector2 != no_object then
			for each object with label "race_flag" do
				if current_object.order > sector2.order then
					if sector3 == no_object or sector3.order > current_object.order then
						sector3 = current_object
						globalStorage.sectorCount += 1
					end
				end
			end
		end


		for each object with label "race_flag" do
			current_object.number[1] = 4
			--current_object.set_waypoint_text("%n", 7)

			if current_object.order == sector1.order then
				current_object.number[1] = 1
				--current_object.set_waypoint_text("%n", 1)
			end
			if current_object.order == sector2.order then
				current_object.number[1] = 2
				--current_object.set_waypoint_text("%n", 2)
			end
			if current_object.order == sector3.order then
				current_object.number[1] = 3
				--current_object.set_waypoint_text("%n", 3)
			end
		end

	end
	-- # Figure out Checkpoint Sectors #


	-- # Hide Invisible Race Objects #
	for each object with label "race_hide" do
		current_object.set_hidden(true)
	end
	-- # Hide Invisible Race Objects #


	-- # Delete Competitive Version Objects #
	if cvDelete == 1 then
		for each object with label "cv_delete" do
			current_object.delete()
		end
	end
	-- # Delete Competitive Version Objects #


	-- # Create Object for storage #
	globalStorage = finalCheckpoint.place_at_me(hill_marker, none,none,0,0,0,none)
	-- # Create Object for storage #


	-- # Set Start Gate Frame #
	if startGate == 0 then -- 20 +/- 5
		globalStorage.startGateFrame = rand( 601 )
		globalStorage.startGateFrame += 900
	end
	if startGate == 1 then -- 30 +/- 10
		globalStorage.startGateFrame = rand( 1201 )
		globalStorage.startGateFrame += 1200
	end
	if startGate == 2 then -- 40 +/- 20
		globalStorage.startGateFrame = rand( 2401 )
		globalStorage.startGateFrame += 1200
	end
	-- # Set Start Gate Frame #


	raceStatus = 1
	host = 1
end

-- # Initialize #




-- # Basic Game Logic #


	-- # Delete Race Gates #
	if raceStatus == 1 and globalStorage.startGateDropped == 0 and frames > globalStorage.startGateFrame then
		for each object with label "race_gate" do
			current_object.delete()
		end
		raceStatus = 2
		frames = 0
		globalStorage.startGateDropped = 1
	end
	-- # Delete Race Gates #


	-- # Count number of alive players #
	numberOfPlayers = 0
	for each player do
		if current_player.biped != no_object then
			numberOfPlayers += 1
		end
	end
	-- # Count number of alive players #


	-- # If someone has met the number of laps, end the round #
	if numberOfLaps != 0 then
		for each player do
			if not current_player.score < numberOfLaps then
				raceStatus = 3
				game.end_round()
			end
		end
	end
	-- # If someone has met the number of laps, end the round #


	-- # If the round time limit has been exceeded, end the round #
	if game.round_time_limit > 0 and game.round_timer.is_zero() then
		raceStatus = 3
		game.end_round()
	end
	-- # If the round time limit has been exceeded, end the round #


	-- # Set up a 5 second timer #
	alias debounce5 = allocate temporary number
	debounce5 = 1

	if raceStatus >= 2 then
		alias tempNumber = allocate temporary number
		tempNumber = frames
		tempNumber /= 300
		tempNumber *= 300
		debounce5 = frames
		debounce5 -= tempNumber
	end
	-- # Set up a 5 second timer #


	for each player do

		-- # Create Objects for storage #
		if current_player.timing == no_object then
			current_player.timing = current_player.biped.place_at_me(hill_marker, none,none,0,0,0,none)
		end
		if current_player.storage == no_object then
			current_player.storage = current_player.biped.place_at_me(hill_marker, none,none,0,0,0,none)
		end
		-- # Create Objects for storage #


		-- # Get Player Timing Object #
		alias timing = allocate temporary object
		timing = current_player.timing
		-- # Get Player Timing Object #


		-- # Get Player Storage Object #
		alias storage = allocate temporary object
		storage = current_player.storage
		-- # Get Player Storage Object #


		-- # Police Track Limits #
		if cvDelete == 1 then
			for each object with label "track_limits" do
				if current_player.onVehicle == 1 and current_object.shape_contains(current_player.biped) and current_player.offTrackDebounce > 420 then
					timing.offTrackCount += 1
					alias penaltyLimit = allocate temporary number
					penaltyLimit = timing.offTrackCount
					penaltyLimit /= 5
					penaltyLimit += 1
					penaltyLimit *= 5
					alias penalty = allocate temporary number
					penalty = timing.offTrackCount
					penalty /= 5
					penalty *= 5

					if penalty == timing.offTrackCount then
						if timing.penalty < 0 then
							timing.penalty = 0
						end
						timing.penalty += 300
						game.show_message_to(current_player, none, "You have earned yourself a 5s penalty bud" )
					end
					if penalty != timing.offTrackCount then
						game.show_message_to(current_player, none, "You have exceeded track limits %n/%n times", timing.offTrackCount, penaltyLimit )
					end
					storage.sectorInvalidated = 1
					storage.lapInvalidated = 1
					current_player.offTrackDebounce = 0
				end
			end
			current_player.offTrackDebounce += 1
		end
		-- # Police Track Limits #


		-- # Set Current Lap time #
		current_player.currentLapSeconds = timing.lapFrames
		current_player.currentLapSeconds /= 60
		alias t = allocate temporary number
		t = current_player.currentLapSeconds
		t *= 60
		current_player.currentLapMilliseconds = timing.lapFrames
		current_player.currentLapMilliseconds -= t
		current_player.currentLapMilliseconds *= 1000
		current_player.currentLapMilliseconds /= 60
		-- # Set Current Lap time #


		-- # Set Player current racing position #
		alias racer = allocate temporary player
		racer = current_player
		alias position = allocate temporary number
		position = 1


		-- # Find out how many players are ahead #
		for each player do
			alias racerTiming = allocate temporary object
			racerTiming = current_player.timing


			if current_player.score > racer.score then
				position += 1
			end

			if current_player.score == racer.score then

				if timing.currentCheckpoint < racerTiming.currentCheckpoint then
					position += 1
				end

				if timing.currentCheckpoint == racerTiming.currentCheckpoint then
					if racerTiming.sectorTimeFrames > timing.sectorTimeFrames then
						position += 1
					end
				end

			end

		end
		-- # Find out how many players are ahead #

		current_player.position = position
		-- # Set Player current racing position #


		-- # Calculate Gaps #
		for each player do
			alias racer = allocate temporary player
			racer = current_player
			alias racerStorage = allocate temporary object
			racerStorage = racer.storage
			alias racerTiming = allocate temporary object
			racerTiming = current_player.timing
			alias tempPlayer = allocate temporary player
			tempPlayer = no_player
			racerStorage.lapsAhead = 0
			racerStorage.lapsBehind = 0

			-- # Find Player Ahead #
			racer.playerAhead = no_player
			alias positionAhead = allocate temporary number
			positionAhead = current_player.position
			positionAhead -= 1
			for each player do
				if positionAhead > 0 and current_player.position == positionAhead then
					racer.playerAhead = current_player
					tempPlayer = current_player
				end
			end

			if tempPlayer == no_player then
				racerStorage.gapAheadSeconds = 0
				racerStorage.gapAheadMilliseconds = 0
			end

			if tempPlayer != no_player then
				alias aheadTiming = allocate temporary object
				aheadTiming = tempPlayer.timing

				-- # Find out how many laps difference the player ahead is #
				if tempPlayer.score == current_player.score then
					racerStorage.lapsAhead = 0
				end
				if tempPlayer.score > current_player.score and aheadTiming.currentCheckpoint > racerTiming.currentCheckpoint then
					racerStorage.lapsAhead = tempPlayer.score
					racerStorage.lapsAhead -= current_player.score
				end
				if racerStorage.lapsAhead < 0 then
					racerStorage.lapsAhead = 0
				end
				-- # Find out how many laps difference the player ahead is #
			end
			-- # Find Player Ahead #


			-- # Find Player Behind #
			tempPlayer = no_player
			racer.playerBehind = no_player
			alias positionBehind = allocate temporary number
			positionBehind = current_player.position
			positionBehind += 1
			for each player do
				if positionBehind > 0 and current_player.position == positionBehind then
					racer.playerBehind = current_player
					tempPlayer = current_player
				end
			end

			if tempPlayer == no_player then
				racerStorage.gapBehindSeconds = 0
				racerStorage.gapBehindMilliseconds = 0
			end

			if tempPlayer != no_player then
				alias behindTiming = allocate temporary object
				behindTiming = tempPlayer.timing

				-- # Find out how many laps difference the player behind is #
				if tempPlayer.score == current_player.score then
					racerStorage.lapsBehind = 0
				end
				if current_player.score > tempPlayer.score and racerTiming.currentCheckpoint > behindTiming.currentCheckpoint then
					racerStorage.lapsBehind = current_player.score
					racerStorage.lapsBehind -= tempPlayer.score
				end
				if racerStorage.lapsBehind < 0 then
					racerStorage.lapsBehind = 0
				end
				-- # Find out how many laps difference the player behind is #
			end
			-- # Find Player Behind #

		end
		-- # Calculate Gaps #

	end


	-- # Increment the frame counter #
	frames += 1
	if frames >= 30000 then
		frames -= 30000
		framesOverflow += 1
	end
	-- # Increment the frame counter #


	-- # Increment the player frame counters #
	if raceStatus >= 2 then
		for each player do
			alias timing = allocate temporary object
			timing = current_player.timing

			timing.lapFrames += 1 -- lapFrames
			timing.sectorTimeFrames += 1 -- sectorFrames
		end
	end
	-- # Increment the player frame counters #

-- # Basic Game Logic #




-- # Handle Vehicles #

for each player do


	-- # Get players current Vehicle #
	alias vehicle = allocate temporary object
	vehicle = no_object
	vehicle = current_player.get_vehicle()
	-- # Get players current Vehicle #


	-- # Remove the Players Vehicle if they die or quit #
	if current_player.killer_type_is(guardians | suicide | kill | betrayal | quit) then
		if current_player.vehicle != no_object then
			vehicle = current_player.vehicle
			if vehicle.player[0] == current_player or vehicle.player[0] == no_player then
				current_player.vehicle.delete()
				current_player.vehicle = no_object
				vehicle.delete()
				vehicle = no_object
			end
		end
	end
	-- # Remove the Players Vehicle if they die or quit #


	-- # Check if Player is on vehicle #
	current_player.onVehicle = 0
	if vehicle != no_object then
		current_player.onVehicle = 1
	end
	-- # Check if Player is on vehicle #



	-- # Handle the Player not being on a Vehicle #
	if current_player.onVehicle == 0 then
		if maxFuel == -1 or current_player.currentFuelLevel > 0 or current_player.currentFuelLevel == -30000 then

		-- # Vehicle Respawn Timer has hit 0 #
		if current_player.vehicleRespawnTimer.is_zero() then
			if current_player.vehicle != no_object then
				vehicle = current_player.vehicle
				if vehicle.player[0] == current_player or vehicle.player[0] == no_player then
					current_player.vehicle.delete()
					current_player.vehicle = no_object
					vehicle = no_object
				end
			end
			current_player.vehicleRespawnTimer.reset()
		end
		-- # Vehicle Respawn Timer has hit 0 #


		-- # If the Player doesn't have a vehicle, Put them in one #
		if current_player.vehicle == no_object then
			if defaultVehicle == 0 then
				vehicle = current_player.biped.place_at_me(mongoose, "Vehicle", none, 0, 0, 0, none)
			end
			if defaultVehicle == 1 then
				vehicle = current_player.biped.place_at_me(warthog, "Vehicle", none, 0, 0, 0, none)
			end
			if defaultVehicle == 2 then
				vehicle = current_player.biped.place_at_me(warthog, "Vehicle", none, 0, 0, 0, troop)
			end
			if defaultVehicle == 3 then
				vehicle = current_player.biped.place_at_me(pickup_truck, "Vehicle", none, 0, 0, 0, none)
			end
			vehicle.player[0] = current_player
			current_player.vehicle = vehicle
			current_player.force_into_vehicle(current_player.vehicle)
			current_player.onVehicle = 1
		end
		-- # If the Player doesn't have a vehicle, Put them in one #


		-- # If the Player still doesn't have a vehicle, start the Vehicle respawn timer #
		current_player.vehicleRespawnTimer.set_rate(-100%)
		-- # If the Player still doesn't have a vehicle, start the Vehicle respawn timer #


		-- # Handle Abandoned Vehicles #
		for each object with label "Vehicle" do
			if current_object.player[0] == no_player then

				-- # If the abandoned vehicle is near the Player, pair them #
				if current_player.vehicle == no_object then
					alias distance = allocate temporary number
					distance = 0
					distance = current_object.get_distance_to(current_player.biped)

					if distance <= 100 then
						current_object.player[0] = current_player
						current_player.vehicle = current_object
					end
				end
				-- # If the abandoned vehicle is near the Player, pair them #

			end
		end
		-- # Handle Abandoned Vehicles #

		end
	end
	-- # Handle the Player not being on a Vehicle #


	-- # Handle the Player being on a Vehicle #
	if current_player.onVehicle == 1 then

		-- # Reset Vehicle Respawn Timer #
		current_player.vehicleRespawnTimer.reset()
		-- # Reset Vehicle Respawn Timer #


		-- # Player is on a new Vehicle #
		if current_player.vehicle != vehicle then
			current_player.vehicle = vehicle
			alias oldPlayer = allocate temporary player
			oldPlayer = vehicle.player[0]
			oldPlayer.vehicle = no_object
			vehicle.player[0] = current_player
		end
		-- # Player is on a new Vehicle #


		-- # Ensure Player is only associated with one Vehicle #
		for each object with label "Vehicle" do
			if current_object != vehicle and current_object.player[0] == current_player then
				current_object.player[0] = no_player
			end
		end
		-- # Ensure Player is only associated with one Vehicle #


		-- # Update Vehicle Speed #
		current_player.vehicleSpeedKPH = 0
		if current_player.biped != no_object then
			current_player.vehicleSpeedKPH = current_player.biped.get_speed()
			current_player.vehicleSpeedKPH *= 109 -- Convert from Feet Per Second to KMH
			current_player.vehicleSpeedKPH /= 100 -- Convert from Feet Per Second to KMH

			if current_player.vehicleSpeedKPH < 0 then
				current_player.vehicleSpeedKPH = 0
			end
			if current_player.vehicleSpeedKPH > 100 then
				current_player.vehicleSpeedKPH = 100
			end
		end
		-- # Update Vehicle Speed #


	end
	-- # Handle the Player being on a Vehicle #


	-- # Set Player/Vehicle to Invincible if enabled in game options #
	if invincibility == 1 then
    	current_player.biped.set_invincibility(1)
    	current_player.vehicle.set_invincibility(1)
    end
    for each object do
       if current_object.is_of_type(kill_boundary) or current_object.is_of_type(soft_kill_boundary) then
          for each player do
             if current_object.shape_contains(current_player.biped) and not current_player.biped.is_of_type(monitor) then
                current_player.biped.set_invincibility(0)
                current_player.vehicle.set_invincibility(0)
             end
          end
       end
    end
	-- # Set Player/Vehicle to Invincible if enabled in game options #

end


-- # Delete all unclaimed abandoned Vehicles #
for each object with label "Vehicle" do
	if current_object.player[0] == no_player then
		current_object.delete()
	end
	if current_object.player[0] != no_player then
		alias racer = allocate temporary player
		racer = current_object.player[0]

		if racer.biped == no_object then
			current_object.delete()
		end

		alias distance = allocate temporary number
		distance = 0
		distance = current_object.get_distance_to(racer.biped)

		if distance >= 200 then
			current_object.delete()
		end
	end
end
-- # Delete all unclaimed abandoned Vehicles #

-- # Handle Vehicles #




-- # Handle UI #

-- # Rotate Dash Status #
if debounce5 == 0 then
	if dashStatus != 4 then
		if dashStatus != 3 then
			dashStatus += 1
		end

		if dashStatus == 2 then
			dashStatus = 0
		end
	end
end
-- # Rotate Dash Status #



for each player do

	-- # Initialize UI #
	if numberOfLaps != 0 then
		current_player.set_objective_text("Hit checkpoints to complete laps.\r\n%n laps to win.", numberOfLaps)
	end
	if numberOfLaps == 0 then
		current_player.set_objective_text("Hit checkpoints to complete laps.")
	end
	-- # Initialize UI #


	-- # Don't display UI if race hasn't started or the Player is not on a mongoose #
	if raceStatus < 2 or current_player.onVehicle == 0 then
		topMiddleWidget.set_visibility(current_player, false)
		bottomMiddleWidget.set_visibility(current_player, false)
		topLeftWidget.set_visibility(current_player, false)
		bottomLeftWidget.set_visibility(current_player, false)
	end
	-- # Don't display UI if race hasn't started or the Player is not on a mongoose #


	-- # Don't display UI if race has started and the Player is on a mongoose #
	if raceStatus >= 2 and current_player.onVehicle == 1 then


		-- # Get Player Timing Object #
		alias timing = allocate temporary object
		timing = current_player.timing
		-- # Get Player Timing Object #


		-- # Get Player Storage Object #
		alias storage = allocate temporary object
		storage = current_player.storage
		-- # Get Player Storage Object #


		-- # Get Player Biped Object #
		alias biped = allocate temporary object
		biped = current_player.biped
		-- # Get Player Biped Object #


		-- # Get Player Vehicle #
		alias vehicle = allocate temporary object
		vehicle = current_player.vehicle
		-- # Get Player Vehicle #


		topMiddleWidget.set_visibility(current_player, true)
		bottomMiddleWidget.set_visibility(current_player, true)
		topLeftWidget.set_visibility(current_player, true)
		bottomLeftWidget.set_visibility(current_player, true)

		if bestLapSeconds == 0 and bestLapMilliseconds == 0 then
			topLeftWidget.set_visibility(current_player, false)
		end

		if current_player.bestLapSeconds == 0 and current_player.bestLapMilliseconds == 0 then
			bottomLeftWidget.set_visibility(current_player, false)
		end


		-- # Update Fuel UI #
		if maxFuel != -1 then
			bottomMiddleWidget.set_meter_params(number, hud_player.currentFuelLevel, globalStorage.maxFuelLevel)
		end
		-- # Update Fuel UI #



		topMiddleWidget.set_text("%n KPH\n   P %n", hud_player.vehicleSpeedKPH, hud_player.position)


		if current_player.currentLapMilliseconds >= 100 then
			bottomMiddleWidget.set_text("%n.%n", hud_player.currentLapSeconds, hud_player.currentLapMilliseconds)
		end
		if current_player.currentLapMilliseconds < 100 then
			bottomMiddleWidget.set_text("%n.0%n", hud_player.currentLapSeconds, hud_player.currentLapMilliseconds)
		end


		if dashStatus == 0 then
			current_player.widget11 = bestLapSeconds
			current_player.widget12 = bestLapMilliseconds
			current_player.widget21 = current_player.bestLapSeconds
			current_player.widget22 = current_player.bestLapMilliseconds
			topLeftWidget.set_text("Fastest Lap: %n.%n", hud_player.widget11, hud_player.widget12)
			bottomLeftWidget.set_text("Personal Best: %n.%n", hud_player.widget21,hud_player.widget22)
		end
		if dashStatus == 1 then
			current_player.widget21 = storage.optimalLapSeconds
			current_player.widget22 = storage.optimalLapMilliseconds
			topLeftWidget.set_text("Fastest Lap: %p\nLap %n", bestLapPlayer, bestLapNumber)
			bottomLeftWidget.set_text("Optimal Lap: %n.%n", hud_player.widget21,hud_player.widget22)
		end
		if dashStatus == 2 then
			alias playerAhead = allocate temporary player
			playerAhead = current_player.playerAhead

			if playerAhead != no_player then
				if storage.gapAheadSeconds != 0 and storage.gapAheadMilliseconds != 0 then
					current_player.widget11 = storage.gapAheadSeconds
					current_player.widget12 = storage.gapAheadMilliseconds
					topLeftWidget.set_text("Gap Ahead: %n.%n", hud_player.widget11, hud_player.widget12)
				end

				if storage.lapsAhead > 1 then
					current_player.widget11 = storage.lapsAhead
					topLeftWidget.set_text("Gap Ahead: %n Lap(s)", hud_player.widget11)
				end
			end

			alias playerBehind = allocate temporary player
			playerBehind = current_player.playerBehind

			if playerBehind != no_player then
				if storage.gapBehindSeconds != 0 and storage.gapBehindMilliseconds != 0 then
					current_player.widget21 = storage.gapBehindSeconds
					current_player.widget22 = storage.gapBehindMilliseconds
					bottomLeftWidget.set_text("Gap Behind: %n.%n", hud_player.widget21, hud_player.widget22)
				end

				if storage.lapsBehind > 1 then
					current_player.widget21 = storage.lapsBehind
					bottomLeftWidget.set_text("Gap Behind: %n Lap(s)", hud_player.widget21)
				end
			end

		end

	end
	-- # Don't display UI if race has started and the Player is on a mongoose #

end
-- # Handle UI #



-- # Handle Checkpoints #
for each player do
	current_player.set_co_op_spawning(true)
	current_player.biped.set_spawn_location_permissions(no_one)


	-- # Get Player Timing Object #
	alias timing = allocate temporary object
	timing = current_player.timing
	-- # Get Player Timing Object #


	-- # Get Player Storage Object #
	alias storage = allocate temporary object
	storage = current_player.storage
	-- # Get Player Storage Object #


	-- # Get players current Vehicle #
	alias vehicle = allocate temporary object
	vehicle = no_object
	vehicle = current_player.get_vehicle()
	-- # Get players current Vehicle #


	-- # If the player is on a vehicle #
	if current_player.onVehicle == 1 then

		if timing.currentCheckpoint < firstCheckpoint.order or timing.currentCheckpoint > finalCheckpoint.order then
			timing.currentCheckpoint = firstCheckpoint.order
		end


		-- # Handle Jokers #
		if requiredJokers > 0 then
			for each object with label "joker" do
				if storage.jokeredThisLap == 1 or current_object.order != timing.currentCheckpoint or timing.jokerCount >= requiredJokers  then
					current_object.set_waypoint_visibility(mod_player, current_player, 0)
					current_object.set_shape_visibility(mod_player, current_player, 0)
				end

				if raceStatus >= 2 and timing.jokerCount < requiredJokers and storage.jokeredThisLap == 0 and current_object.spawn_sequence == timing.currentCheckpoint then
					current_object.team = team[1]
					current_object.set_waypoint_icon(vip)
					current_object.set_waypoint_visibility(mod_player, current_player, 1)
					current_object.set_shape_visibility(mod_player, current_player, 1)
					current_object.set_waypoint_priority(normal)
					if lowPriorityWaypoints == 1 then
						current_object.set_waypoint_priority(low)
					end

					if current_object.shape_contains(current_player.biped) then
						timing.jokerCount += 1
						storage.jokeredThisLap = 1
						game.show_message_to(current_player, none, "You have completed %n/%n jokers", timing.jokerCount, requiredJokers )
					end
				end
			end
		end
		-- # Handle Jokers #


		for each object with label "race_flag" do
			current_object.set_waypoint_visibility(mod_player, current_player, 0)
			current_object.set_shape_visibility(mod_player, current_player, 0)

			if current_object.order == timing.currentCheckpoint then-- If checkpoint is the players current checkpoint
				current_object.set_waypoint_visibility(mod_player, current_player, 1)
				current_object.set_shape_visibility(mod_player, current_player, 1)

				-- # The player has hit the checkpoint #
				if current_object.shape_contains(current_player.biped) then-- If the player is currently inside the checkpoint

					-- # Holeshot Marker #
					if holeshotPlayer == no_player then
						holeshotPlayer = current_player
						if numberOfPlayers != 1 then
							for each player do
								game.show_message_to(current_player, none, "%p got the holeshot", holeshotPlayer )
							end
						end
					end
					-- # Holeshot Marker #


					-- # Player should spawn at this checkpoint after hitting it #
					for each object with label "race_flag" do
						current_object.set_spawn_location_permissions(mod_player, current_player, 0)
					end
					current_object.set_spawn_location_permissions(mod_player, current_player, 1)
					current_player.set_primary_respawn_object(current_object)
					-- # Player should spawn at this checkpoint after hitting it #


					-- # Handle Sector Times #
					if timing.sectorTimeFrames != 0 then
						alias sectorTimeFrames = allocate temporary number
						sectorTimeFrames = timing.sectorTimeFrames -- Sector start frame
						framesIn = sectorTimeFrames
						timeFromFrames()
						alias bestOverallSector = allocate temporary number
						bestOverallSector = 0
						alias bestPersonalSector = allocate temporary number
						bestPersonalSector = 0


						if current_object.number[1] == 1 and current_player.score > 0 and storage.pittedThisLap < 1 then
							if storage.sectorInvalidated == 0 then
								if timing.bestSector1TimeFrames == 0 or timing.bestSector1TimeFrames > sectorTimeFrames then
									timing.bestSector1TimeFrames = sectorTimeFrames
									bestPersonalSector = 1
								end
								if current_object.number[2] == 0 or current_object.number[2] > sectorTimeFrames then
									current_object.number[2] = sectorTimeFrames
									bestOverallSector = 1
								end
							end

							-- # Send Sector Complete Notifications #
							if bestOverallSector == 1 then
								game.show_message_to(current_player, none, "Overall Best Sector 1 time! %n.%n", secondsOut, millisecondsOut )
							end
							if bestOverallSector != 1 and bestPersonalSector == 1 then
								game.show_message_to(current_player, none, "Personal Best Sector 1 time! %n.%n", secondsOut, millisecondsOut )
							end
							if bestOverallSector != 1 and bestPersonalSector != 1 then
								game.show_message_to(current_player, none, "Sector 1: %n.%n", secondsOut, millisecondsOut )
							end
							-- # Send Sector Complete Notifications #

							storage.sectorInvalidated = 0
						end
						if current_object.number[1] == 2 and current_player.score > 0 and storage.pittedThisLap < 1 then
							if storage.sectorInvalidated == 0 then
								if timing.bestSector2TimeFrames == 0 or timing.bestSector2TimeFrames > sectorTimeFrames then
									timing.bestSector2TimeFrames = sectorTimeFrames
									bestPersonalSector = 1
								end
								if current_object.number[3] == 0 or current_object.number[3] > sectorTimeFrames then
									current_object.number[3] = sectorTimeFrames
									bestOverallSector = 1
								end
							end

							-- # Send Sector Complete Notifications #
							if bestOverallSector == 1 then
								game.show_message_to(current_player, none, "Overall Best Sector 2 time! %n.%n", secondsOut, millisecondsOut )
							end
							if bestOverallSector != 1 and bestPersonalSector == 1 then
								game.show_message_to(current_player, none, "Personal Best Sector 2 time! %n.%n", secondsOut, millisecondsOut )
							end
							if bestOverallSector != 1 and bestPersonalSector != 1 then
								game.show_message_to(current_player, none, "Sector 2: %n.%n", secondsOut, millisecondsOut )
							end
							-- # Send Sector Complete Notifications #

							storage.sectorInvalidated = 0
						end
						if current_object.number[1] == 3 and current_player.score > 0 and storage.pittedThisLap < 1 then
							if storage.sectorInvalidated == 0 then
								if timing.bestSector3TimeFrames == 0 or timing.bestSector3TimeFrames > sectorTimeFrames then
									timing.bestSector3TimeFrames = sectorTimeFrames
									bestPersonalSector = 1
								end
								if current_object.number[4] == 0 or current_object.number[4] > sectorTimeFrames then
									current_object.number[4] = sectorTimeFrames
									bestOverallSector = 1
								end
							end

							-- # Send Sector Complete Notifications #
							if bestOverallSector == 1 then
								game.show_message_to(current_player, none, "Overall Best Sector 3 time! %n.%n", secondsOut, millisecondsOut )
							end
							if bestOverallSector != 1 and bestPersonalSector == 1 then
								game.show_message_to(current_player, none, "Personal Best Sector 3 time! %n.%n", secondsOut, millisecondsOut )
							end
							if bestOverallSector != 1 and bestPersonalSector != 1 then
								game.show_message_to(current_player, none, "Sector 3: %n.%n", secondsOut, millisecondsOut )
							end
							-- # Send Sector Complete Notifications #
						end
					end
					timing.sectorTimeFrames = 0 -- sectorStartFrame -- Set Frame number the user started the current sector on

					storage.sectorInvalidated = 0
					-- # Handle Sector Times #


					-- # Update Optimal Laptime #
					framesIn = timing.bestSector1TimeFrames
					framesIn += timing.bestSector2TimeFrames
					framesIn += timing.bestSector3TimeFrames
					timeFromFrames()
					storage.optimalLapSeconds = secondsOut
					storage.optimalLapMilliseconds = millisecondsOut

					if globalStorage.sectorCount >= 1 and timing.bestSector1TimeFrames == 0 then
						storage.optimalLapSeconds = 0
						storage.optimalLapMilliseconds = 0
					end
					if globalStorage.sectorCount >= 2 and timing.bestSector2TimeFrames == 0 then
						storage.optimalLapSeconds = 0
						storage.optimalLapMilliseconds = 0
					end
					if globalStorage.sectorCount >= 3 and timing.bestSector3TimeFrames == 0 then
						storage.optimalLapSeconds = 0
						storage.optimalLapMilliseconds = 0
					end
					-- # Update Optimal Laptime #


					-- # Find next checkpoint #
					alias nextCheckpointNumber = allocate temporary number
					nextCheckpointNumber = finalCheckpoint.order
					nextCheckpointNumber += 1 -- Number of maximum checkpoints + 1
					for each object with label "race_flag" do
						if current_object.order > timing.currentCheckpoint and current_object.order < nextCheckpointNumber then
							nextCheckpointNumber = current_object.order
						end
					end
					-- # Find next checkpoint #


					-- # Update Player Current Checkpoint #
					timing.currentCheckpoint = nextCheckpointNumber
					-- # Update Player Current Checkpoint #


					-- # Player has completed a lap #
					if timing.currentCheckpoint > finalCheckpoint.order then

						-- # Notify the user of how much fuel was used #
						if maxFuel != -1 then
						   	if current_player.score == 0 and vehicle.lapStartingFuel == 0 then
							   	vehicle.lapStartingFuel = globalStorage.maxFuelLevel
						   	end

						   	if vehicle.lapStartingFuel != 0 then
							   	vehicle.fuelUsedLastLap = vehicle.lapStartingFuel
							   	vehicle.fuelUsedLastLap -= current_player.currentFuelLevel
							   	if vehicle.lapStartingFuel > current_player.currentFuelLevel then
								   	game.show_message_to(current_player, none, "Fuel Used last lap %n", vehicle.fuelUsedLastLap )
							   	end
						   	end
							vehicle.lapStartingFuel = current_player.currentFuelLevel
						end
						-- # Notify the user of how much fuel was used #

						if raceStatus >= 2 then

							-- # If you are on the same lap as the player behind you #
							alias behindPlayer = allocate temporary player
							behindPlayer = current_player.playerBehind
							alias behindTiming = allocate temporary object
							behindTiming = behindPlayer.timing
							alias behindStorage = allocate temporary object
							behindStorage = behindPlayer.storage

							if behindPlayer != no_player and storage.lapsBehind == 0 then
								framesIn = timing.lapFrames
								framesIn -= behindTiming.lapFrames
								timeFromFrames()
								storage.gapBehindSeconds = secondsOut
								storage.gapBehindMilliseconds = millisecondsOut
								behindStorage.gapAheadSeconds = secondsOut
								behindStorage.gapAheadMilliseconds = millisecondsOut
							end
							-- # If you are on the same lap as the player behind you #

						   -- # If you are on the same lap as the player ahead of you #
						   alias aheadPlayer = allocate temporary player
						   aheadPlayer = current_player.playerAhead
						   alias aheadTiming = allocate temporary object
						   aheadTiming = aheadPlayer.timing
						   alias aheadStorage = allocate temporary object
						   aheadStorage = aheadPlayer.storage

						   if aheadPlayer != no_player and storage.lapsAhead == 0 then
								framesIn = aheadTiming.lapFrames
								timeFromFrames()
								storage.gapAheadSeconds = secondsOut
								storage.gapAheadMilliseconds = millisecondsOut
								aheadStorage.gapBehindSeconds = secondsOut
								aheadStorage.gapBehindMilliseconds = millisecondsOut
						   end
						   -- # If you are on the same lap as the player ahead of you #


							alias bestPersonalLap = allocate temporary number
							bestPersonalLap = 0
							alias bestOverallLap = allocate temporary number
							bestOverallLap = 0

							-- # Reset Player checkpoint counter #
							timing.currentCheckpoint = firstCheckpoint.order
							-- # Reset Player checkpoint counter #


							-- # Increment Player Score #
							current_player.score += 1
							-- # Increment Player Score #


							-- # Set Player Best Lap #
							if storage.pittedThisLap < 1 and storage.lapInvalidated == 0 then
								if current_player.score >= 2 and current_player.bestLapSeconds == 0 and current_player.bestLapMilliseconds == 0 then
									bestPersonalLap = 1
									current_player.bestLapSeconds = current_player.currentLapSeconds
									current_player.bestLapMilliseconds = current_player.currentLapMilliseconds
									current_player.bestLapNumber = current_player.score
								end
								if current_player.currentLapSeconds < current_player.bestLapSeconds and storage.lapInvalidated == 0 then
									bestPersonalLap = 1
									current_player.bestLapSeconds = current_player.currentLapSeconds
									current_player.bestLapMilliseconds = current_player.currentLapMilliseconds
									current_player.bestLapNumber = current_player.score
								end
								if current_player.currentLapSeconds == current_player.bestLapSeconds and current_player.currentLapMilliseconds < current_player.bestLapMilliseconds and storage.lapInvalidated == 0 then
									bestPersonalLap = 1
									current_player.bestLapSeconds = current_player.currentLapSeconds
									current_player.bestLapMilliseconds = current_player.currentLapMilliseconds
									current_player.bestLapNumber = current_player.score
								end
							end
							-- # Set Player Best Lap #


							-- # Set Fastest Laptime #
							if storage.pittedThisLap < 1 and storage.lapInvalidated == 0 then
								if current_player.score >= 2 and bestLapSeconds == 0 and bestLapMilliseconds == 0 then
									bestOverallLap = 1
									bestLapSeconds = current_player.currentLapSeconds
									bestLapMilliseconds = current_player.currentLapMilliseconds
									bestLapPlayer = current_player
									bestLapNumber = current_player.score
								end
								if current_player.currentLapSeconds < bestLapSeconds then
									bestOverallLap = 1
									bestLapSeconds = current_player.currentLapSeconds
									bestLapMilliseconds = current_player.currentLapMilliseconds
									bestLapPlayer = current_player
									bestLapNumber = current_player.score
								end
								if current_player.currentLapSeconds == bestLapSeconds and current_player.currentLapMilliseconds < bestLapMilliseconds then
									bestOverallLap = 1
									bestLapSeconds = current_player.currentLapSeconds
									bestLapMilliseconds = current_player.currentLapMilliseconds
									bestLapPlayer = current_player
									bestLapNumber = current_player.score
								end
							end
							-- # Set Fastest Laptime #


							-- # Send Lap Complete Notifications #
							if bestOverallLap == 1 and storage.lapInvalidated == 0 then
								if current_player.currentLapMilliseconds >= 100 then
									game.show_message_to(current_player, none, "Overall Best lap time! %n.%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
								if current_player.currentLapMilliseconds < 100 then
									game.show_message_to(current_player, none, "Overall Best lap time! %n.0%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
							end
							if bestOverallLap != 1 and bestPersonalLap == 1 and storage.lapInvalidated == 0 then
								if current_player.currentLapMilliseconds >= 100 then
									game.show_message_to(current_player, none, "Personal Best lap time! %n.%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
								if current_player.currentLapMilliseconds < 100 then
									game.show_message_to(current_player, none, "Personal Best lap time! %n.0%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
							end
							if bestOverallLap != 1 and bestPersonalLap != 1 then
								if current_player.currentLapMilliseconds >= 100 then
									game.show_message_to(current_player, none, "Lap Complete: %n.%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
								if current_player.currentLapMilliseconds < 100 then
									game.show_message_to(current_player, none, "Lap Complete: %n.0%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
							end
							send_incident(lap_complete, current_player, no_player)
							-- # Send Lap Complete Notifications #


							-- # Subtract from pit status -1 #
							storage.pittedThisLap -= 1
							-- # Subtract from pit status -1 #


							-- # Notify everyone of the final lap #
							do
								alias whiteFlagLap = allocate temporary number
								whiteFlagLap = numberOfLaps -- # Number of laps
								whiteFlagLap -= 1
								if current_player.score == whiteFlagLap then
									alias scoreboardPosition = allocate temporary number
									scoreboardPosition = 0
									scoreboardPosition = current_player.get_scoreboard_pos()
									if scoreboardPosition == 1 then
										send_incident(final_lap, current_player, all_players)
									end
								end
							end
							-- # Notify everyone of the final lap #


							storage.lapInvalidated = 0
							storage.jokeredThisLap = 0 -- Reset joker flag
							timing.lapFrames = 1 -- lapFrames -- Reset lap frame count
						end
					end
					-- # Player has completed a lap #


					-- # Start the race when someone hits a checkpoint #
					if raceStatus < 2 then
						raceStatus = 2
						timing.lapFrames = 1 -- lapFrames
						frames = 0
					end
					-- # Start the race when someone hits a checkpoint #


				end
				-- # The player has hit the checkpoint #

			end
		end
	end
	-- # If the player is on a vehicle #
end
-- # Handle Checkpoints #




-- # Handle Fuel #
if maxFuel != -1 then

	-- # Associate pitbox with player #
	for each object with label "pit_stop" do
		alias found = allocate temporary number
		found = 0
		for each player do
			if current_player.pitbox == 999 or current_player.pitbox == current_object.spawn_sequence then
				current_object.set_waypoint_visibility(mod_player, current_player, 1)
				current_object.set_shape_visibility(mod_player, current_player, 1)
				current_object.set_waypoint_priority(normal)
				if lowPriorityWaypoints == 1 then
					current_object.set_waypoint_priority(low)
				end
				current_object.set_waypoint_icon(arrow)
				current_object.set_waypoint_text("Pit Road")
			end
			if current_player.pitbox != 999 and current_player.pitbox != current_object.spawn_sequence then
				current_object.set_waypoint_visibility(mod_player, current_player, 0)
				current_object.set_shape_visibility(mod_player, current_player, 0)
			end

			if current_object.shape_contains( current_player.biped ) and current_player.pitbox == 999 then
				if current_object.number[0] < 300 then
					current_object.number[0] += 1
					found = 1
				end
				if current_object.number[0] >= 300 then
					current_player.pitbox = current_object.spawn_sequence
					current_object.number[0] = 0
				end
			end
		end
		if found == 0 then
			current_object.number[0] = 0
		end
	end
	-- # Associate pitbox with player #


	if raceStatus >= 2 then

		alias debounce = allocate temporary number
		alias temp = allocate temporary number
		temp = frames
		temp /= 20
		temp *= 20
		debounce = frames
		debounce -= temp


		if debounce == 0 then -- run 3 times a second

			for each player do

				-- # Get players current Vehicle #
				alias vehicle = allocate temporary object
				vehicle = no_object
				vehicle = current_player.get_vehicle()
				-- # Get players current Vehicle #


				-- # Get Player Timing Object #
				alias timing = allocate temporary object
				timing = current_player.timing
				-- # Get Player Timing Object #


				-- # Get Player Storage Object #
				alias storage = allocate temporary object
				storage = current_player.storage
				-- # Get Player Storage Object #


				-- # Initialize Fuel #
				if current_player.currentFuelLevel == -30000 then				-- -30000 is a magic number to indicate that the player has never had fuel before

					-- # Set Max Fuel Level #
					if globalStorage.maxFuelLevel == 0 then
						globalStorage.maxFuelLevel = 6000								-- Set the Base fuel level
						globalStorage.maxFuelLevel *= 50								-- Scale Base fuel level up to a useable value with a magic number
						globalStorage.maxFuelLevel *= maxFuel							-- Max Fuel is a percentage of fuel selected in the gametype
						globalStorage.maxFuelLevel /= 100								-- Convert Max Fuel to a percentage
					end
					-- # Set Max Fuel Level #

					current_player.currentFuelLevel = globalStorage.maxFuelLevel		-- Set the players currentFuelLevel to the maxFuelLevel
					-- # Set Max Fuel Level #
				end
				-- # Initialize Fuel #


				-- # Initialize Refuel Amount #
				if vehicle.refuelAmount == 0 then
					vehicle.refuelAmount = globalStorage.maxFuelLevel					-- Start with our max fuel level
					vehicle.refuelAmount /= 3									-- Divide it by 3 because we run this update code 3x per second
					vehicle.refuelAmount /= refuelRate							-- Divide it by the desired pit stop length selected in the gametype options
				end
				-- # Initialize Refuel Amount #


				-- # Remove Player from Vehicle if they have no fuel #
				if current_player.currentFuelLevel <= 0 and current_player.currentFuelLevel != -30000 then
					current_player.biped.detach()
					current_player.onVehicle = 0
					current_player.vehicle.delete()
				end
				-- # Remove Player from Vehicle if they have no fuel #


				if current_player.onVehicle == 1 and current_player.currentFuelLevel > 0 and current_player.biped != no_object then
					alias fueling = allocate temporary number
					fueling = 0

					-- # Update Vehicle Fuel #
					do
						alias fuelUsage = allocate temporary number
						fuelUsage = 95												-- Base fuel usage

						alias fuelCalc = allocate temporary number
						fuelCalc = current_player.vehicleSpeedKPH					-- Start the fuel calculation with the vehicles current speed
						fuelCalc -= vehicle.startingFuelSpeed						-- Subtract the vehicles speed from three tenths of a second ago
						fuelCalc *= 3												-- Multiply by a magic number to scale this up to a useable value

						fuelUsage += fuelCalc										-- Add the rate of change fuel calculation to the base fuel usage


						if vehicle.startingFuelSpeed > 55 and current_player.vehicleSpeedKPH > 55 and vehicle.startingFuelSpeed <= current_player.vehicleSpeedKPH then -- 55kmh being roughly the speed that we shift to 2nd
							fuelUsage -= 20											-- Fuel efficiency slightly better in 2nd gear
						end

						if vehicle.startingFuelSpeed == 0 and current_player.vehicleSpeedKPH == 0 or fuelUsage < 5 then
							fuelUsage = 5											-- Idle fuel usage
						end


						current_player.currentFuelLevel -= fuelUsage				-- Subtract the fuel usage calculation from the users current fuel level
						vehicle.startingFuelSpeed = current_player.vehicleSpeedKPH	-- Store the vehicles current speed for the next time we run this calculation
					end
					-- # Update Vehicle Fuel #


					-- # Refuel Vehicles that are parked on a Pit Box #
					for each object with label "pit_stop" do
						alias pitBox = allocate temporary object
						pitBox = current_object

						if raceStatus >= 2 then
							--pitbox.set_waypoint_visibility(mod_player, current_player, 0)
							--pitbox.set_shape_visibility(mod_player, current_player, 0)
						end

						if current_player.pitbox == 999 or current_player.pitbox == pitbox.spawn_sequence then
							--pitBox.set_shape_visibility(everyone)
							--pitBox.set_waypoint_visibility(everyone)
							pitBox.set_waypoint_priority(normal)
							pitBox.set_waypoint_range(0, 100)
							if lowPriorityWaypoints == 1 then
								pitBox.set_waypoint_priority(low)
							end
							pitBox.set_waypoint_icon(arrow)
							pitBox.set_waypoint_text("Pit Road")
						end

						if current_player.vehicleSpeedKPH <= 0 and pitBox.shape_contains( vehicle ) and current_player.currentFuelLevel < globalStorage.maxFuelLevel then
							if current_player.pitbox == 999 or current_player.pitbox == pitbox.spawn_sequence then
								if timing.penalty > 0 then
									alias notify = allocate temporary number
									notify = timing.penalty
									notify /= 60
									notify *= 60

									if timing.penalty == notify then
										notify /= 60
										game.show_message_to(current_player, none, "Serving Time Penalty %ns", notify )
									end
									timing.penalty -= 20
								end

								if current_player.currentFuelLevel < globalStorage.maxFuelLevel and timing.penalty <= 0 then
									 storage.pittedThisLap = 2 --	# Set Pit Status #
									 alias maximumRefuelAmount = allocate temporary number
									 maximumRefuelAmount = globalStorage.maxFuelLevel
									 maximumRefuelAmount -= current_player.currentFuelLevel
									 alias refuelAmount = allocate temporary number
									 refuelAmount = vehicle.refuelAmount

									 if refuelAmount > maximumRefuelAmount then
									 	refuelAmount = maximumRefuelAmount
									 end

									 current_player.currentFuelLevel += refuelAmount
									 vehicle.fuelTaken += refuelAmount

									 if current_player.currentFuelLevel > globalStorage.maxFuelLevel then
										 current_player.currentFuelLevel = globalStorage.maxFuelLevel
									 end
									 fueling = 1
								end
							end
						end

					end
					-- # Refuel Vehicles that are parked on a Pit Box #


					-- # Alert the racer how much fuel they refilled #
					if fueling == 0 then
						if vehicle.fuelTaken > 0 then
							game.show_message_to(current_player, none, "Amount of fuel refilled %n", vehicle.fuelTaken )
						end
						vehicle.fuelTaken = 0
					end
					-- # Alert the racer how much fuel they refilled #

				end

			end
		end

	end
end
-- # Handle Fuel #



on local: do
	if host == 0 then


		--	# Hide Invisible Race Objects #
		for each object with label "race_hide" do
			current_object.set_hidden(true)
		end
		--	# Hide Invisible Race Objects #


		-- # Hide Race Gates #
		alias localStartGateFrame = allocate temporary number
		localStartGateFrame = globalStorage.startGateFrame
		localStartGateFrame -= 6 -- How much earlier should the gates visually disappear before they physically disappear
		if raceStatus == 1 and globalStorage.startGateDropped == 0 and frames > localStartGateFrame then
			for each object with label "race_gate" do
				current_object.set_hidden(true)
			end
		end
		-- # Hide Race Gates #


		-- # Detect Client Player --
		for each object with label "target" do
			current_object.delete()
		end
		if client == no_player  then
			for each player do
                current_player.biped.detach()
                alias weapon = allocate temporary object
                weapon = current_player.try_get_weapon(primary)
                alias target = allocate temporary object
                target = weapon.place_at_me(monitor, "target", suppress_effect, 3, 1, 1, none)
                target.attach_to(weapon, 3, 1, 1, relative)
                target.detach()
                alias get = allocate temporary object
                get = current_player.get_crosshair_target()
                if get != no_object then
                   client = current_player
                end
            end
        end
		-- # Detect Client Player --


		if raceStatus >= 2 then

			-- # Get players current Vehicle #
			alias vehicle = allocate temporary object
			vehicle = no_object
			vehicle = client.get_vehicle()
			-- # Get players current Vehicle #


			-- # Get Player Timing Object #
			alias timing = allocate temporary object
			timing = client.timing
			-- # Get Player Timing Object #


			-- # Set Current Local Lap time #
			localCurrentLapSeconds = localLapFrames
			localCurrentLapSeconds /= 60
			alias t = allocate temporary number
			t = localCurrentLapSeconds
			t *= 60
			localCurrentLapMilliseconds = localLapFrames
			localCurrentLapMilliseconds -= t
			localCurrentLapMilliseconds *= 1000
			localCurrentLapMilliseconds /= 60
			-- # Set Current Local Lap time #


			-- # Display the players current lap time #
			if localCurrentLapMilliseconds >= 100 then
				bottomMiddleWidget.set_text("%n.%n", localCurrentLapSeconds, localCurrentLapMilliseconds )
			end
			if localCurrentLapMilliseconds < 100 then
				bottomMiddleWidget.set_text("%n.0%n", localCurrentLapSeconds, localCurrentLapMilliseconds )
			end
			-- # Display the players current lap time #


			-- # Increment the player frame counters #
			localLapFrames += 1 -- lapFrames
			-- # Increment the player frame counters #


			-- # Player has completed a lap #
			if localLapFrames > 15 and client.onVehicle == 1 then
				for each object with label "race_flag" do
					if current_object.order == timing.currentCheckpoint and timing.currentCheckpoint == finalCheckpoint.order then
						if current_object.shape_contains(client.biped) then
							localLapFrames = 0
						end
					end
				end
			end
			-- # Player has completed a lap #


			-- # Update Vehicle Speed #
			client.vehicleSpeedKPH = 0
			if client.onVehicle == 1 and client.biped != no_object then
				client.vehicleSpeedKPH = client.biped.get_speed()
				client.vehicleSpeedKPH *= 109 -- Convert from Feet Per Second to KMH
				client.vehicleSpeedKPH /= 100 -- Convert from Feet Per Second to KMH

				if client.vehicleSpeedKPH < 0 then
					client.vehicleSpeedKPH = 0
				end
				if client.vehicleSpeedKPH > 100 then
					client.vehicleSpeedKPH = 100
				end
			end
			-- # Update Vehicle Speed #

		end


	end
end





on host migration: do


		--	# Hide Invisible Race Objects #
		for each object with label "race_hide" do
			current_object.set_hidden(true)
		end
		--	# Hide Invisible Race Objects #



		-- # Delete Race Gates #
		for each object with label "race_gate" do
			current_object.delete()
		end
		-- # Delete Race Gates #



end