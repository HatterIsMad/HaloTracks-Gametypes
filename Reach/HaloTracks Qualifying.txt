-- /* GLOBAL VARIABLES */

alias	bestLapSeconds					= global.number[0]
alias	bestLapMilliseconds				= global.number[1]
alias	bestLapNumber					= global.number[2]
alias	frames							= global.number[3]
alias	framesOverflow					= global.number[4]
alias	host							= global.number[5]
alias	localCurrentLapSeconds			= global.number[6]
alias	localCurrentLapMilliseconds		= global.number[7]
alias	localLapFrames					= global.number[8]
alias	numberOfPlayers					= global.number[9]

alias	dashStatus						= global.number[10]
-- dashStatus = 0 -- Show Dash page 1
-- dashStatus = 1 -- Show Dash page 2
-- dashStatus = 2 -- Unused
-- dashStatus = 3 -- Unused
-- dashStatus = 4 -- Show Post Race Dash

alias	raceStatus						= global.number[11]
-- raceStatus = 0 -- Game is starting, we haven't spawned yet
-- raceStatus = 1 -- Gridding has started
-- raceStatus = 2 -- Race has started
-- raceStatus = 3 -- Race time period has ended
-- raceStatus = 4 -- Race has ended

declare	bestLapSeconds					with network priority high
declare	bestLapMilliseconds				with network priority high
declare	bestLapNumber					with network priority high
declare	frames							with network priority high	= 0
declare	framesOverflow					with network priority high	= 1
declare	host							with network priority local	= 0
declare	localCurrentLapSeconds			with network priority local	= 0
declare	localCurrentLapMilliseconds		with network priority local	= 0
declare	dashStatus						with network priority local	= 0
declare	raceStatus						with network priority high	= 0


alias	bestLapPlayer					= global.player[0]
alias	client							= global.player[1]
declare bestLapPlayer					with network priority high
declare client							with network priority local


alias	finalCheckpoint					= global.object[0]
alias	firstCheckpoint					= global.object[1]
alias	globalStorage					= global.object[2]

-- /* GLOBAL VARIABLES */



-- /* SCRIPT OPTIONS */

alias	numberOfLaps					= script_option[0]
alias	invincibility					= script_option[1]
alias	waypointVisibility				= script_option[2]
alias	startGate						= script_option[3]
alias	defaultVehicle					= script_option[4]
alias	f1Mode							= script_option[5]

-- /* SCRIPT OPTIONS */



-- /* PLAYER VARIABLES */

alias	position						= player.number[0]
alias	vehicleSpeedKPH					= player.number[1]
alias	currentLapSeconds				= player.number[2]
alias	currentLapMilliseconds			= player.number[3]
alias	widget21						= player.number[4]
alias	widget22						= player.number[5]
alias	widget11						= player.number[6]
alias	widget12						= player.number[7]
alias	vehicleRespawnTimer				= player.timer[0]
alias	onVehicle						= player.timer[1]
alias	offTrackDebounce				= player.timer[2]
alias	outlapIgnored 				    = player.timer[3]

declare	player.position					with network priority high	= 1
declare	player.vehicleSpeedKPH			with network priority local
declare	player.currentLapMilliseconds	with network priority local
declare	player.currentLapSeconds    	with network priority local


declare	player.vehicleRespawnTimer		= 7


alias	vehicle							= player.object[0]
alias	timing							= player.object[1]
alias	storage							= player.object[2]
alias	storage2						= player.object[3]


alias	bestLapSeconds					= player.script_stat[0]
alias	bestLapMilliseconds				= player.script_stat[1]
alias	bestLapNumber					= player.script_stat[2]
alias	bestLapFrames				    = player.script_stat[3]

-- /* PLAYER VARIABLES */



-- /* OBJECT VARIABLES */


	-- /* Player Timing Object */
	alias	sectorTimeFrames				= object.number[1]
	alias	lapFrames						= object.number[2]
	alias	currentCheckpoint				= object.number[5]
	alias	respawnTimers					= object.number[6]
	alias	bestSector1TimeFrames			= object.timer[0]
	alias	bestSector2TimeFrames			= object.timer[1]
	alias	bestSector3TimeFrames			= object.timer[2]
	alias	respawnTimer					= object.timer[3]
	alias	respawnObject					= object.object[0]
	-- /* Player Timing Object */


	-- /* Player Storage Object */
	alias	optimalLapSeconds				= object.number[6]
	alias	optimalLapMilliseconds			= object.number[7]
	alias	sectorInvalidated				= object.timer[2]
	alias	lapInvalidated					= object.timer[3]
	-- /* Player Storage Object */


	-- /* Checkpoint Object */
	alias	order							= object.number[0]
	alias	sector							= object.number[1]
	alias	bestSectorTimeFrames			= object.number[2]
	-- /* Checkpoint Object */


	-- /* Global Storage Object */
	alias	startGateFrame					= object.number[1]
	alias	startGateDropped				= object.number[2]
	alias	sectorCount						= object.number[3]
	alias	checkpointCount					= object.number[4]
	alias	suddenDeath 					= object.number[5]
	-- /* Global Storage Object */


-- /* OBJECT VARIABLES */



-- /* HUD WIDGETS */

alias	topMiddleWidget					= script_widget[0]
alias	bottomMiddleWidget				= script_widget[1]
alias	topLeftWidget					= script_widget[2]
alias	bottomLeftWidget				= script_widget[3]

-- /* HUD WIDGETS */



-- # Functions #


alias framesIn = allocate temporary number
alias secondsOut = allocate temporary number
alias millisecondsOut = allocate temporary number
function timeFromFrames()
	secondsOut = framesIn
	secondsOut /= 60

	alias t = allocate temporary number
	t = secondsOut
	t *= 60

	millisecondsOut = framesIn
	millisecondsOut -= t
	millisecondsOut *= 1000
	millisecondsOut /= 60
end


-- # Functions #



-- # Initialize #

on init: do


	-- # Initialize Checkpoints #
	for each object with label "race_flag" do
		current_object.order = current_object.spawn_sequence
		current_object.team = neutral_team
		current_object.set_invincibility(1)


        if waypointVisibility >= 2 then
            current_object.set_waypoint_icon(diamond)
        end
        if waypointVisibility >= 3 then
			current_object.team = team[1]
        end


		if finalCheckpoint == no_object or current_object.order > finalCheckpoint.order then
			finalCheckpoint = current_object
		end

		if firstCheckpoint == no_object or current_object.order < firstCheckpoint.order then
			firstCheckpoint = current_object
		end

	end
	-- # Initialize Checkpoints #


	-- # Reorder Checkpoints #
	alias count = allocate temporary number
	count = 0
	for each object with label "race_flag" do

		-- # Find Next Checkpoint #
		alias nextCheckpointOrder = allocate temporary number
		nextCheckpointOrder = -1
		for each object with label "race_flag" do
			if nextCheckpointOrder < 0 and current_object.order >= count then
				nextCheckpointOrder = current_object.order
			end
			if current_object.order >= count and current_object.order < nextCheckpointOrder then
				nextCheckpointOrder = current_object.order
			end
		end
		-- # Find Next Checkpoint #

		-- # Change the order value on all checkpoints with that value #
		for each object with label "race_flag" do
			if nextCheckpointOrder >= 0 and nextCheckpointOrder == current_object.order then
				current_object.order = count
			end
		end
		-- # Change the order value on all checkpoints with that value #

		count += 1
	end
	-- # Reorder Checkpoints #


	-- # Create Object for storage #
	globalStorage = finalCheckpoint.place_at_me( hill_marker, none, never_garbage_collect, 0, 0, 0, none )
	-- # Create Object for storage #


	-- # Count Distinct Checkpoints #
	globalStorage.checkpointCount = 0
	for each object with label "race_flag" do
		for each object with label "race_flag" do
			if current_object.order == globalStorage.checkpointCount then
				globalStorage.checkpointCount += 1
			end
		end
	end
	-- # Count Distinct Checkpoints #


	-- # Figure out Checkpoint Sectors #
	do
		alias sector1 = allocate temporary object
		sector1 = no_object
		alias sector2 = allocate temporary object
		sector2 = no_object
		alias sector3 = allocate temporary object
		sector3 = no_object

		if globalStorage.checkpointCount <= 3 then
			for each object with label "race_flag" do
				if current_object.order == 0 then
					sector1 = current_object
				end
				if current_object.order == 1 then
					sector2 = current_object
				end
				if current_object.order == 2 then
					sector3 = current_object
				end
			end
		end


		alias spacing = allocate temporary number
		spacing = globalStorage.checkpointCount
		spacing /= 3
		alias order = allocate temporary number
		order = globalStorage.checkpointCount
		order -= 1
		order -= spacing

		if globalStorage.checkpointCount > 3 then
			sector3 = finalCheckpoint

			for each object with label "race_flag" do
				if current_object.order == order then
					sector2 = current_object
				end
			end

			order -= spacing

			for each object with label "race_flag" do
				if current_object.order == order then
					sector1 = current_object
				end
			end

		end


		if sector1 != no_object then
			globalStorage.sectorCount = 1
		end
		if sector2 != no_object then
			globalStorage.sectorCount = 2
		end
		if sector3 != no_object then
			globalStorage.sectorCount = 3
		end

		for each object with label "race_flag" do
			current_object.sector = 4

			if sector1 != no_object and current_object.order == sector1.order then
				current_object.sector = 1
			end
			if sector2 != no_object and current_object.order == sector2.order then
				current_object.sector = 2
			end
			if sector3 != no_object and current_object.order == sector3.order then
				current_object.sector = 3
			end
		end

	end
	-- # Figure out Checkpoint Sectors #


	-- # Hide Invisible Race Objects #
	for each object with label "race_hide" do
		current_object.set_hidden(true)
	end
	-- # Hide Invisible Race Objects #


	-- # Delete Competitive Version Objects #
	for each object with label "cv_delete" do
		current_object.delete()
	end
	-- # Delete Competitive Version Objects #


	-- # Set Start Gate Frame #
	if startGate == 1 then -- 20 +/- 5
		globalStorage.startGateFrame = rand( 601 )
		globalStorage.startGateFrame += 900
	end
	if startGate == 2 then -- 30 +/- 10
		globalStorage.startGateFrame = rand( 1201 )
		globalStorage.startGateFrame += 1200
	end
	if startGate == 3 then -- 40 +/- 20
		globalStorage.startGateFrame = rand( 2401 )
		globalStorage.startGateFrame += 1200
	end
	-- # Set Start Gate Frame #


	raceStatus = 1
	host = 1
end

-- # Initialize #



-- # Basic Game Logic #


	-- # Initial Spawn Point #
	for each player do
		if current_player.biped != no_object and current_player.storage2 == no_object then
			alias found = allocate temporary number
			found = 0

			-- # Check to ensure that grid spots exist on the map #
			for each object with label "grid_spot" do
				found = 1
			end
			-- # Check to ensure that grid spots exist on the map #

			if found == 1 then
			    -- # Check to see if the player is already assigned to a grid spot #
			    for each object with label "grid_spot" do
				    if current_object.player[0] == current_player then
					    current_player.storage2 = current_object
				    end
			    end
			    -- # Check to see if the player is already assigned to a grid spot #


			    if current_player.storage2 == no_object then
                    alias gridSpot = allocate temporary object
                    gridSpot = no_object

			        for each object with label "grid_spot" do
				        if current_object.player[0] == no_player then
				            if gridSpot == no_object or current_object.spawn_sequence < gridSpot.spawn_sequence then
				                gridSpot = current_object
				            end
				        end
			        end

			        if gridSpot != no_object then
                        current_player.storage2 = gridSpot
                        gridSpot.player[0] = current_player
			        end
			    end

			    -- # Spawn them at their grid spot #
                current_player.biped.attach_to(current_player.storage2, 0, 0, 2, relative)
                current_player.biped.detach()
                current_player.biped.copy_rotation_from(current_player.storage2, false)
			    -- # Spawn them at their grid spot #
			end
		end
	end
	-- # Initial Spawn Point #


	-- # Delete Race Gates #
	if startGate != 0 and raceStatus == 1 and globalStorage.startGateDropped == 0 and frames > globalStorage.startGateFrame then
		for each object with label "race_gate" do
			current_object.delete()
		end
		raceStatus = 2
		frames = 0
		globalStorage.startGateDropped = 1
	end
	-- # Delete Race Gates #


	-- # Count number of alive players #
	numberOfPlayers = 0
	for each player do
		if current_player.biped != no_object then
			numberOfPlayers += 1
		end
	end
	-- # Count number of alive players #


	-- # If everyone has met the number of laps, end the round #
	if numberOfLaps != 0 and globalStorage.suddenDeath == 0 then
		alias done = allocate temporary number
		done = 1

	    for each player do
		    if current_player.score < numberOfLaps then
		        done = 0
		    end
		    if current_player.score >= numberOfLaps and not current_player.biped.is_of_type(monitor) then
                alias oldBody = allocate temporary object
                oldBody = current_player.biped
                oldBody.detach()
                current_player.vehicle.delete()
                alias mon = allocate temporary object
                mon = current_player.biped.place_at_me(monitor, none, never_garbage_collect, 0, 0, 5, none)
                mon.max_health = 100
                mon.set_invincibility(1)
                mon.remove_weapon(primary, true)
                current_player.set_biped(mon)
                oldBody.delete()
				current_player.score = current_player.bestLapFrames
				current_player.score *= -1
		    end
	    end

	    if done == 1 then
	        raceStatus = 3
	        globalStorage.suddenDeath = 1
	        game.sudden_death_timer.set_rate(-100%)
	    end
	end
	-- # If everyone has met the number of laps, end the round #


	-- # If the round time limit has been exceeded, end the round #
	if game.round_time_limit > 0 and globalStorage.suddenDeath == 0 then
		if game.round_timer.is_zero() then
			raceStatus = 3
	        globalStorage.suddenDeath = 1
	        game.sudden_death_timer.set_rate(-100%)
	        for each player do
	            if not current_player.biped.is_of_type(monitor) then
		            alias oldBody = allocate temporary object
		            oldBody = current_player.biped
		            oldBody.detach()
                    current_player.vehicle.delete()
		            alias mon = allocate temporary object
		            mon = current_player.biped.place_at_me(monitor, none, never_garbage_collect, 0, 0, 5, none)
		            mon.max_health = 100
                    mon.set_invincibility(1)
                    mon.remove_weapon(primary, true)
                    current_player.set_biped(mon)
                    oldBody.delete()
					current_player.score = current_player.bestLapFrames
					current_player.score *= -1
                end
            end
		end
	end
	-- # If the round time limit has been exceeded, end the round #


	-- # If grace period is over, end the round #
    if globalStorage.suddenDeath == 1 and game.sudden_death_timer.is_zero() then
       game.end_round()
    end
	-- # If grace period is over, end the round #


	-- # Set up a 5 second timer #
	alias debounce5 = allocate temporary number
	debounce5 = 1

	if raceStatus >= 2 then
		alias tempNumber = allocate temporary number
		tempNumber = frames
		tempNumber /= 300
		tempNumber *= 300
		debounce5 = frames
		debounce5 -= tempNumber
	end
	-- # Set up a 5 second timer #


	for each player do


		-- # Create Objects for storage #
		if current_player.timing == no_object then
			current_player.timing = current_player.biped.place_at_me(hill_marker, none,never_garbage_collect,0,0,0,none)
			--current_player.timing.attach_to(current_player.biped, 10, 0, 0, relative)
		end
		if current_player.storage == no_object then
			current_player.storage = current_player.biped.place_at_me(hill_marker, none,never_garbage_collect,0,0,0,none)
		end
		-- # Create Objects for storage #


		-- # Get Player Timing Object #
		alias timing = allocate temporary object
		timing = current_player.timing
		-- # Get Player Timing Object #


		-- # Get Player Storage Object #
		alias storage = allocate temporary object
		storage = current_player.storage
		-- # Get Player Storage Object #


		if current_player.biped == no_object then
			timing.respawnTimer += 1
			current_player.vehicle.set_invincibility( 0 )
			current_player.vehicle.kill( true )
		end

		current_player.biped.health = 100
        current_player.vehicle.set_invincibility( 1 )

		if current_player.onVehicle == 0 then
            alias weapon = allocate temporary object
            weapon = current_player.get_weapon(primary)
            if weapon != no_object then
                current_player.biped.remove_weapon(primary, true)
            end
        end


		-- # Police Track Limits #
		for each object with label "track_limits" do
			if current_player.onVehicle == 1 and current_object.shape_contains(current_player.biped) and current_player.offTrackDebounce > 420 then
				game.show_message_to(current_player, none, "You have exceeded track limits. Your lap has been invalidated." )
				storage.sectorInvalidated = 1
				storage.lapInvalidated = 1
			end
		end
		current_player.offTrackDebounce += 1
		-- # Police Track Limits #


		-- # Set Current Lap time #
		current_player.currentLapSeconds = timing.lapFrames
		current_player.currentLapSeconds /= 60
		alias t = allocate temporary number
		t = current_player.currentLapSeconds
		t *= 60
		current_player.currentLapMilliseconds = timing.lapFrames
		current_player.currentLapMilliseconds -= t
		current_player.currentLapMilliseconds *= 1000
		current_player.currentLapMilliseconds /= 60
		-- # Set Current Lap time #


		-- # Set Player current racing position #
		alias racer = allocate temporary player
		racer = current_player
		alias position = allocate temporary number
		position = 1

		-- # Find out how many players are ahead #
		for each player do
			alias racerTiming = allocate temporary object
			racerTiming = current_player.timing

			if current_player.bestLapFrames < racer.bestLapFrames then
				position += 1
			end

		end
		-- # Find out how many players are ahead #

		current_player.position = position
		-- # Set Player current racing position #


		-- # Respawn Player #
		if current_player.biped != no_object and timing.respawnTimer >= 60 then
		    if timing.respawnObject == no_object and current_player.storage2 != no_object and current_player.storage2.has_forge_label("grid_spot") then
			    timing.respawnObject = current_player.storage2
		    end

		    if timing.respawnTimer >= 60 and timing.respawnObject != no_object then
                current_player.biped.attach_to(timing.respawnObject, 0, 0, 2, relative)
                current_player.biped.detach()
                current_player.biped.copy_rotation_from(timing.respawnObject, false)
       	    end
		    timing.respawnTimer = 0
		end
		-- # Respawn Player #

	end


	-- # Increment the frame counter #
	frames += 1
	if frames >= 30000 then
		frames -= 30000
		framesOverflow += 1
	end
	-- # Increment the frame counter #


	-- # Increment the player frame counters #
	if raceStatus >= 2 then
		for each player do
			alias timing = allocate temporary object
			timing = current_player.timing

			timing.lapFrames += 1 -- lapFrames
			timing.sectorTimeFrames += 1 -- sectorFrames
		end
	end
	-- # Increment the player frame counters #


	-- # Handle Waypoint Priority #
	for each object do
		if current_object.has_forge_label("grid_spot") or current_object.has_forge_label("race_flag") then
			if waypointVisibility == 1 then
				current_object.set_waypoint_priority(low)
			end
			if waypointVisibility >= 2 then
				current_object.set_waypoint_priority(normal)
			end
			if waypointVisibility >= 3 then
				current_object.set_waypoint_priority(high)
			end
		end
	end
	-- # Handle Waypoint Priority #



-- # Basic Game Logic #



-- # Handle Vehicles #

for each player do


	-- # Get players current Vehicle #
	alias vehicle = allocate temporary object
	vehicle = no_object
	vehicle = current_player.get_vehicle()
	-- # Get players current Vehicle #


	-- # Get players timing object #
	alias timing = allocate temporary object
	timing = no_object
	timing = current_player.timing
	-- # Get players timing object #


	-- # Remove the Players Vehicle if they die or quit #
	if current_player.killer_type_is(guardians | suicide | kill | betrayal | quit) then
		if current_player.vehicle != no_object then
			vehicle = current_player.vehicle
			if vehicle.player[0] == current_player or vehicle.player[0] == no_player then
				current_player.vehicle.delete()
				current_player.vehicle = no_object
				vehicle.delete()
				vehicle = no_object
			end
		end
	end
	-- # Remove the Players Vehicle if they die or quit #


	current_player.onVehicle = 0

    if not current_player.biped.is_of_type(monitor) then

	    -- # Check if Player is on vehicle #
	    if vehicle != no_object then
		    current_player.onVehicle = 1
	    end
	    -- # Check if Player is on vehicle #



	    -- # Handle the Player not being on a Vehicle #
	    if current_player.onVehicle == 0 then

		    -- # Vehicle Respawn Timer has hit 0 #
		    if current_player.vehicleRespawnTimer.is_zero() then
			    if current_player.vehicle != no_object then
				    vehicle = current_player.vehicle
				    if vehicle.player[0] == current_player or vehicle.player[0] == no_player then
					    current_player.vehicle.delete()
					    current_player.vehicle = no_object
					    vehicle = no_object
				    end
			    end
			    current_player.vehicleRespawnTimer.reset()
		    end
		    -- # Vehicle Respawn Timer has hit 0 #


		    -- # If the Player doesn't have a vehicle, Put them in one #
		    if current_player.vehicle == no_object then
			    if defaultVehicle == 0 then
				    vehicle = current_player.biped.place_at_me(mongoose, "Vehicle", none, 0, 0, 0, none)
			    end
			    if defaultVehicle == 1 then
				    vehicle = current_player.biped.place_at_me(warthog, "Vehicle", none, 0, 0, 0, none)
			    end
			    if defaultVehicle == 2 then
				    vehicle = current_player.biped.place_at_me(warthog, "Vehicle", none, 0, 0, 0, troop)
			    end
			    if defaultVehicle == 3 then
				    vehicle = current_player.biped.place_at_me(pickup_truck, "Vehicle", none, 0, 0, 0, none)
			    end
			    vehicle.player[0] = current_player
			    current_player.vehicle = vehicle
			    current_player.force_into_vehicle(current_player.vehicle)
			    current_player.onVehicle = 1
		    end
		    -- # If the Player doesn't have a vehicle, Put them in one #


		    -- # If the Player still doesn't have a vehicle, start the Vehicle respawn timer #
		    current_player.vehicleRespawnTimer.set_rate(-100%)
		    -- # If the Player still doesn't have a vehicle, start the Vehicle respawn timer #


		    -- # Handle Abandoned Vehicles #
		    for each object with label "Vehicle" do
			    if current_object.player[0] == no_player then

				    -- # If the abandoned vehicle is near the Player, pair them #
				    if current_player.vehicle == no_object then
					    alias distance = allocate temporary number
					    distance = 0
					    distance = current_object.get_distance_to(current_player.biped)

					    if distance <= 100 then
						    current_object.player[0] = current_player
						    current_player.vehicle = current_object
					    end
				    end
				    -- # If the abandoned vehicle is near the Player, pair them #

			    end
		    end
		    -- # Handle Abandoned Vehicles #

	    end
	    -- # Handle the Player not being on a Vehicle #


	    -- # Handle the Player being on a Vehicle #
	    if current_player.onVehicle == 1 then

		    -- # Reset Vehicle Respawn Timer #
		    current_player.vehicleRespawnTimer.reset()
		    -- # Reset Vehicle Respawn Timer #


		    -- # Player is on a new Vehicle #
		    if current_player.vehicle != vehicle then
			    current_player.vehicle = vehicle
			    alias oldPlayer = allocate temporary player
			    oldPlayer = vehicle.player[0]
			    oldPlayer.vehicle = no_object
			    vehicle.player[0] = current_player
		    end
		    -- # Player is on a new Vehicle #


		    -- # Ensure Player is only associated with one Vehicle #
		    for each object with label "Vehicle" do
			    if current_object != vehicle and current_object.player[0] == current_player then
				    current_object.player[0] = no_player
			    end
		    end
		    -- # Ensure Player is only associated with one Vehicle #


		    -- # Update Vehicle Speed #
		    current_player.vehicleSpeedKPH = 0
		    if current_player.biped != no_object then
			    current_player.vehicleSpeedKPH = current_player.biped.get_speed()
			    current_player.vehicleSpeedKPH *= 109 -- Convert from Feet Per Second to KMH
			    current_player.vehicleSpeedKPH /= 100 -- Convert from Feet Per Second to KMH

			    if current_player.vehicleSpeedKPH < 0 then
				    current_player.vehicleSpeedKPH = 0
			    end
			    if current_player.vehicleSpeedKPH > 200 then
				    current_player.vehicleSpeedKPH = 200
			    end
		    end
		    -- # Update Vehicle Speed #

	    end

	end
	-- # Handle the Player being on a Vehicle #


	-- # Set Player/Vehicle to Invincible if enabled in game options #
	if invincibility == 1 then
		current_player.biped.set_invincibility(1)
		current_player.vehicle.set_invincibility(1)
		for each object do
			if current_object.is_of_type(kill_boundary) or current_object.is_of_type(soft_kill_boundary) then
				for each player do
					if current_object.shape_contains(current_player.biped) and not current_player.biped.is_of_type(monitor) then
						current_player.biped.set_invincibility(0)
						current_player.vehicle.set_invincibility(0)
					end
				end
			end
		end
	end
	-- # Set Player/Vehicle to Invincible if enabled in game options #


	-- # Kill balls should kill players #
	for each object do
		if current_object.is_of_type(kill_ball) then
			for each player do
            	alias distance = allocate temporary number
            	distance = 0
            	distance = current_object.get_distance_to(current_player.biped)
				if distance < 25 then
					current_player.biped.set_invincibility(0)
					current_player.vehicle.set_invincibility(0)
					current_player.biped.kill(false)
					current_player.vehicle.kill(true)
				end
			end
		end
	end
	-- # Kill balls should kill players #

end


-- # Delete all unclaimed abandoned Vehicles #
for each object with label "Vehicle" do
	if current_object.player[0] == no_player then
		current_object.delete()
	end
	if current_object.player[0] != no_player then
		alias racer = allocate temporary player
		racer = current_object.player[0]

		if racer.biped == no_object then
			current_object.delete()
		end

		alias distance = allocate temporary number
		distance = 0
		distance = current_object.get_distance_to(racer.biped)

		if distance >= 200 then
			current_object.delete()
		end
	end
end
-- # Delete all unclaimed abandoned Vehicles #

-- # Handle Vehicles #



-- # Handle UI #

-- # Rotate Dash Status #
if debounce5 == 0 then
	if dashStatus != 4 then
		if dashStatus != 2 then
			dashStatus += 1
		end

		if dashStatus == 2 then
			dashStatus = 0
		end
	end
end
-- # Rotate Dash Status #



for each player do

	-- # Initialize UI #
	if numberOfLaps != 0 then
		current_player.set_objective_text("Hit checkpoints to complete laps.\r\n%n laps to win.", numberOfLaps)
	end
	if numberOfLaps == 0 then
		current_player.set_objective_text("Hit checkpoints to complete laps.")
	end
	-- # Initialize UI #


	-- # Don't display UI if race hasn't started or the Player is not on a mongoose #
	if raceStatus < 2 or current_player.onVehicle == 0 then
		topMiddleWidget.set_visibility(current_player, false)
		bottomMiddleWidget.set_visibility(current_player, false)
		topLeftWidget.set_visibility(current_player, false)
		bottomLeftWidget.set_visibility(current_player, false)
	end
	-- # Don't display UI if race hasn't started or the Player is not on a mongoose #


	-- # Don't display UI if race has started and the Player is on a mongoose #
	if raceStatus >= 2 and current_player.onVehicle == 1 then


		-- # Get Player Timing Object #
		alias timing = allocate temporary object
		timing = current_player.timing
		-- # Get Player Timing Object #


		-- # Get Player Storage Object #
		alias storage = allocate temporary object
		storage = current_player.storage
		-- # Get Player Storage Object #


		-- # Get Player Biped Object #
		alias biped = allocate temporary object
		biped = current_player.biped
		-- # Get Player Biped Object #


		-- # Get Player Vehicle #
		alias vehicle = allocate temporary object
		vehicle = current_player.vehicle
		-- # Get Player Vehicle #


		topMiddleWidget.set_visibility(current_player, true)
		bottomMiddleWidget.set_visibility(current_player, true)
		topLeftWidget.set_visibility(current_player, true)
		bottomLeftWidget.set_visibility(current_player, true)


		topMiddleWidget.set_text("%n KPH\n  P %n", hud_player.vehicleSpeedKPH, hud_player.position)
		bottomMiddleWidget.set_text("%n.%n", hud_player.currentLapSeconds, hud_player.currentLapMilliseconds)


		-- # We don't need to show dashStatus 1 or 2 if it is a single person lobby #
		if dashStatus == 1 then
			if numberOfPlayers == 1 then
				dashStatus = 0
			end
		end
		-- # We don't need to show dashStatus 1 or 2 if it is a single person lobby #


		if dashStatus == 0 then
			current_player.widget11 = bestLapSeconds
			current_player.widget12 = bestLapMilliseconds
			topLeftWidget.set_value_text("Fastest Lap: %n.%n", hud_player.widget11, hud_player.widget12)
			current_player.widget21 = storage.optimalLapSeconds
			current_player.widget22 = storage.optimalLapMilliseconds
			bottomLeftWidget.set_value_text("Optimal Lap: %n.%n", hud_player.widget21,hud_player.widget22)
		end
		if dashStatus == 1 then
			topLeftWidget.set_value_text("Fastest Lap: %p\nLap %n", bestLapPlayer, bestLapNumber)
			current_player.widget21 = current_player.bestLapSeconds
			current_player.widget22 = current_player.bestLapMilliseconds
			bottomLeftWidget.set_value_text("Personal Best: %n.%n", hud_player.widget21,hud_player.widget22)
		end

	end
	-- # Don't display UI if race has started and the Player is on a mongoose #

end
-- # Handle UI #



-- # Handle Checkpoints #
for each player do

	-- # Get Player Timing Object #
	alias timing = allocate temporary object
	timing = current_player.timing
	-- # Get Player Timing Object #


	-- # Get Player Storage Object #
	alias storage = allocate temporary object
	storage = current_player.storage
	-- # Get Player Storage Object #


	-- # Get players current Vehicle #
	alias vehicle = allocate temporary object
	vehicle = no_object
	vehicle = current_player.get_vehicle()
	-- # Get players current Vehicle #


	if current_player.outlapIgnored == 0 and timing.currentCheckpoint == 0 then
		storage.lapInvalidated = 1
		storage.sectorInvalidated = 1
	end


	-- # If the player is on a vehicle #
	if current_player.onVehicle == 1 then

		if timing.currentCheckpoint < firstCheckpoint.order or timing.currentCheckpoint > finalCheckpoint.order then
			timing.currentCheckpoint = firstCheckpoint.order
		end


		for each object with label "race_flag" do
			current_object.set_waypoint_visibility(mod_player, current_player, 0)
			current_object.set_shape_visibility(mod_player, current_player, 0)

			if current_object.order == timing.currentCheckpoint then-- If checkpoint is the players current checkpoint
                if waypointVisibility >= 1 then
                    current_object.set_waypoint_visibility(mod_player, current_player, 1)
                end
                if waypointVisibility >= 2 then
                    if current_object.order == finalCheckpoint.order then
                        current_object.set_waypoint_icon(vip)
                    end
                    current_object.set_shape_visibility(mod_player, current_player, 1)
                end


				-- # The player has hit the checkpoint #
				if current_object.shape_contains(current_player.biped) then-- If the player is currently inside the checkpoint

					-- # Player should spawn at this checkpoint after hitting it #
					timing.respawnObject = current_object
					-- # Player should spawn at this checkpoint after hitting it #


					-- # Handle Sector Times #
					if timing.sectorTimeFrames != 0 then
						alias sectorTimeFrames = allocate temporary number
						sectorTimeFrames = timing.sectorTimeFrames -- Sector start frame
						framesIn = sectorTimeFrames
						timeFromFrames()
						alias bestOverallSector = allocate temporary number
						bestOverallSector = 0
						alias bestPersonalSector = allocate temporary number
						bestPersonalSector = 0


						if current_object.sector == 1 then
							if storage.sectorInvalidated == 0 then
								if timing.bestSector1TimeFrames == 0 or timing.bestSector1TimeFrames > sectorTimeFrames then
									timing.bestSector1TimeFrames = sectorTimeFrames
									bestPersonalSector = 1
								end
								if current_object.bestSectorTimeFrames == 0 or current_object.bestSectorTimeFrames > sectorTimeFrames then
									current_object.bestSectorTimeFrames = sectorTimeFrames
									bestOverallSector = 1
								end
							end

							-- # Send Sector Complete Notifications #
							if bestOverallSector == 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Overall Best Sector 1 time! %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Overall Best Sector 1 time! %n.%n", secondsOut, millisecondsOut )
								end
							end
							if bestOverallSector != 1 and bestPersonalSector == 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Personal Best Sector 1 time! %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Personal Best Sector 1 time! %n.%n", secondsOut, millisecondsOut )
								end
							end
							if bestOverallSector != 1 and bestPersonalSector != 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Sector 1: %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Sector 1: %n.%n", secondsOut, millisecondsOut )
								end
							end
							-- # Send Sector Complete Notifications #
						    timing.sectorTimeFrames = 0 -- sectorStartFrame -- Set Frame number the user started the current sector on
						    storage.sectorInvalidated = 0
						end
						if current_object.sector == 2 then
							if storage.sectorInvalidated == 0 then
								if timing.bestSector2TimeFrames == 0 or timing.bestSector2TimeFrames > sectorTimeFrames then
									timing.bestSector2TimeFrames = sectorTimeFrames
									bestPersonalSector = 1
								end
								if current_object.bestSectorTimeFrames == 0 or current_object.bestSectorTimeFrames > sectorTimeFrames then
									current_object.bestSectorTimeFrames = sectorTimeFrames
									bestOverallSector = 1
								end
							end

							-- # Send Sector Complete Notifications #
							if bestOverallSector == 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Overall Best Sector 2 time! %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Overall Best Sector 2 time! %n.%n", secondsOut, millisecondsOut )
								end
							end
							if bestOverallSector != 1 and bestPersonalSector == 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Personal Best Sector 2 time! %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Personal Best Sector 2 time! %n.%n", secondsOut, millisecondsOut )
								end
							end
							if bestOverallSector != 1 and bestPersonalSector != 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Sector 2: %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Sector 2: %n.%n", secondsOut, millisecondsOut )
								end
							end
							-- # Send Sector Complete Notifications #
						    timing.sectorTimeFrames = 0 -- sectorStartFrame -- Set Frame number the user started the current sector on
						    storage.sectorInvalidated = 0
						end
						if current_object.sector == 3 then
							if storage.sectorInvalidated == 0 then
								if timing.bestSector3TimeFrames == 0 or timing.bestSector3TimeFrames > sectorTimeFrames then
									timing.bestSector3TimeFrames = sectorTimeFrames
									bestPersonalSector = 1
								end
								if current_object.bestSectorTimeFrames == 0 or current_object.bestSectorTimeFrames > sectorTimeFrames then
									current_object.bestSectorTimeFrames = sectorTimeFrames
									bestOverallSector = 1
								end
							end

							-- # Send Sector Complete Notifications #
							if bestOverallSector == 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Overall Best Sector 3 time! %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Overall Best Sector 3 time! %n.%n", secondsOut, millisecondsOut )
								end
							end
							if bestOverallSector != 1 and bestPersonalSector == 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Personal Best Sector 3 time! %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Personal Best Sector 3 time! %n.%n", secondsOut, millisecondsOut )
								end
							end
							if bestOverallSector != 1 and bestPersonalSector != 1 then
								if millisecondsOut < 100 then
									game.show_message_to(current_player, none, "Sector 3: %n.0%n", secondsOut, millisecondsOut )
								end
								if millisecondsOut > 100 then
									game.show_message_to(current_player, none, "Sector 3: %n.%n", secondsOut, millisecondsOut )
								end
							end
							-- # Send Sector Complete Notifications #
						    timing.sectorTimeFrames = 0 -- sectorStartFrame -- Set Frame number the user started the current sector on
						    storage.sectorInvalidated = 0
						end
					end
					-- # Handle Sector Times #


					-- # Update Optimal Laptime #
					framesIn = timing.bestSector1TimeFrames
					framesIn += timing.bestSector2TimeFrames
					framesIn += timing.bestSector3TimeFrames
					timeFromFrames()
					storage.optimalLapSeconds = secondsOut
					storage.optimalLapMilliseconds = millisecondsOut

					if globalStorage.sectorCount >= 1 and timing.bestSector1TimeFrames == 0 then
						storage.optimalLapSeconds = 0
						storage.optimalLapMilliseconds = 0
					end
					if globalStorage.sectorCount >= 2 and timing.bestSector2TimeFrames == 0 then
						storage.optimalLapSeconds = 0
						storage.optimalLapMilliseconds = 0
					end
					if globalStorage.sectorCount >= 3 and timing.bestSector3TimeFrames == 0 then
						storage.optimalLapSeconds = 0
						storage.optimalLapMilliseconds = 0
					end
					-- # Update Optimal Laptime #


					-- # Find next checkpoint #
					alias nextCheckpointNumber = allocate temporary number
					nextCheckpointNumber = finalCheckpoint.order
					nextCheckpointNumber += 1 -- Number of maximum checkpoints + 1
					for each object with label "race_flag" do
						if current_object.order > timing.currentCheckpoint and current_object.order < nextCheckpointNumber then
							nextCheckpointNumber = current_object.order
						end
					end
					-- # Find next checkpoint #


					-- # Update Player Current Checkpoint #
					timing.currentCheckpoint = nextCheckpointNumber
					-- # Update Player Current Checkpoint #


					-- # Player has completed a lap #
					if timing.currentCheckpoint > finalCheckpoint.order then


						if raceStatus >= 2 then

							alias bestPersonalLap = allocate temporary number
							bestPersonalLap = 0
							alias bestOverallLap = allocate temporary number
							bestOverallLap = 0

							-- # Reset Player checkpoint counter #
							timing.currentCheckpoint = firstCheckpoint.order
							-- # Reset Player checkpoint counter #


							-- # Increment Player Score #
							if current_player.outlapIgnored == 1 then
								current_player.score += 1
							end
							-- # Increment Player Score #


							-- # Set Player Best Lap #
							if storage.lapInvalidated == 0 then
								if current_player.bestLapSeconds == 0 and current_player.bestLapMilliseconds == 0 then
									bestPersonalLap = 1
									current_player.bestLapFrames = timing.lapFrames
									current_player.bestLapFrames -= 1
									current_player.bestLapSeconds = current_player.currentLapSeconds
									current_player.bestLapMilliseconds = current_player.currentLapMilliseconds
									current_player.bestLapNumber = current_player.score
								end
								if current_player.currentLapSeconds < current_player.bestLapSeconds then
									bestPersonalLap = 1
									current_player.bestLapFrames = timing.lapFrames
									current_player.bestLapFrames -= 1
									current_player.bestLapSeconds = current_player.currentLapSeconds
									current_player.bestLapMilliseconds = current_player.currentLapMilliseconds
									current_player.bestLapNumber = current_player.score
								end
								if current_player.currentLapSeconds == current_player.bestLapSeconds and current_player.currentLapMilliseconds < current_player.bestLapMilliseconds then
									bestPersonalLap = 1
									current_player.bestLapFrames = timing.lapFrames
									current_player.bestLapFrames -= 1
									current_player.bestLapSeconds = current_player.currentLapSeconds
									current_player.bestLapMilliseconds = current_player.currentLapMilliseconds
									current_player.bestLapNumber = current_player.score
								end
							end
							-- # Set Player Best Lap #


							-- # Set Fastest Laptime #
							if storage.lapInvalidated == 0 then
								if bestLapSeconds == 0 and bestLapMilliseconds == 0 then
									bestOverallLap = 1
									bestLapSeconds = current_player.currentLapSeconds
									bestLapMilliseconds = current_player.currentLapMilliseconds
									bestLapPlayer = current_player
									bestLapNumber = current_player.score
								end
								if current_player.currentLapSeconds < bestLapSeconds then
									bestOverallLap = 1
									bestLapSeconds = current_player.currentLapSeconds
									bestLapMilliseconds = current_player.currentLapMilliseconds
									bestLapPlayer = current_player
									bestLapNumber = current_player.score
								end
								if current_player.currentLapSeconds == bestLapSeconds and current_player.currentLapMilliseconds < bestLapMilliseconds then
									bestOverallLap = 1
									bestLapSeconds = current_player.currentLapSeconds
									bestLapMilliseconds = current_player.currentLapMilliseconds
									bestLapPlayer = current_player
									bestLapNumber = current_player.score
								end
							end
							-- # Set Fastest Laptime #


							-- # Send Lap Complete Notifications #
							if bestOverallLap == 1 and storage.lapInvalidated == 0 then
								if current_player.currentLapMilliseconds >= 100 then
									game.show_message_to(current_player, none, "Overall Best lap time! %n.%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
								if current_player.currentLapMilliseconds < 100 then
									game.show_message_to(current_player, none, "Overall Best lap time! %n.0%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
							end
							if bestOverallLap != 1 and bestPersonalLap == 1 and storage.lapInvalidated == 0 then
								if current_player.currentLapMilliseconds >= 100 then
									game.show_message_to(current_player, none, "Personal Best lap time! %n.%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
								if current_player.currentLapMilliseconds < 100 then
									game.show_message_to(current_player, none, "Personal Best lap time! %n.0%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
							end
							if bestOverallLap != 1 and bestPersonalLap != 1 then
								if current_player.currentLapMilliseconds >= 100 then
									game.show_message_to(current_player, none, "Lap Complete: %n.%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
								if current_player.currentLapMilliseconds < 100 then
									game.show_message_to(current_player, none, "Lap Complete: %n.0%n", current_player.currentLapSeconds, current_player.currentLapMilliseconds )
								end
							end
							send_incident(lap_complete, current_player, no_player)
							-- # Send Lap Complete Notifications #


							-- # Notify everyone of the final lap #
							do
								alias whiteFlagLap = allocate temporary number
								whiteFlagLap = numberOfLaps -- # Number of laps
								whiteFlagLap -= 1
								if current_player.score == whiteFlagLap then
									alias scoreboardPosition = allocate temporary number
									scoreboardPosition = 0
									scoreboardPosition = current_player.get_scoreboard_pos()
									if scoreboardPosition == 1 then
										send_incident(final_lap, current_player, current_player)
									end
								end
							end
							-- # Notify everyone of the final lap #

							current_player.outlapIgnored = 1
							storage.lapInvalidated = 0
							timing.lapFrames = 1 -- lapFrames -- Reset lap frame count
						end
					end
					-- # Player has completed a lap #


					-- # Start the race when someone hits a checkpoint #
					if raceStatus < 2 then
						raceStatus = 2
						timing.lapFrames = 1 -- lapFrames
						frames = 0
					end
					-- # Start the race when someone hits a checkpoint #


				end
				-- # The player has hit the checkpoint #

			end
		end
	end
	-- # If the player is on a vehicle #
end
-- # Handle Checkpoints #




on local: do
	if host == 0 then


		--	# Hide Invisible Race Objects #
		for each object with label "race_hide" do
			current_object.set_hidden(true)
		end
		--	# Hide Invisible Race Objects #


		-- # Hide Race Gates #
		if startGate != 0 then
			alias localStartGateFrame = allocate temporary number
			localStartGateFrame = globalStorage.startGateFrame
			localStartGateFrame -= 6 -- How much earlier should the gates visually disappear before they physically disappear
			if raceStatus == 1 and globalStorage.startGateDropped == 0 and frames > localStartGateFrame then
				for each object with label "race_gate" do
					current_object.set_hidden(true)
				end
			end
		end
		-- # Hide Race Gates #


		-- # Detect Client Player --
		for each object with label "target" do
			current_object.delete()
		end
		if client == no_player	then
			for each player do
				current_player.biped.detach()
				alias weapon = allocate temporary object
				weapon = current_player.try_get_weapon(primary)
				alias target = allocate temporary object
				target = weapon.place_at_me(monitor, "target", suppress_effect, 3, 1, 1, none)
				target.attach_to(weapon, 3, 1, 1, relative)
				target.detach()
				alias get = allocate temporary object
				get = current_player.get_crosshair_target()
				if get != no_object then
					client = current_player
				end
			end
		end
		-- # Detect Client Player --


		if raceStatus >= 2 then

			-- # Get players current Vehicle #
			alias vehicle = allocate temporary object
			vehicle = no_object
			vehicle = client.get_vehicle()
			-- # Get players current Vehicle #


			-- # Get Player Timing Object #
			alias timing = allocate temporary object
			timing = client.timing
			-- # Get Player Timing Object #


			-- # Set Current Local Lap time #
			localCurrentLapSeconds = localLapFrames
			localCurrentLapSeconds /= 60
			alias t = allocate temporary number
			t = localCurrentLapSeconds
			t *= 60
			localCurrentLapMilliseconds = localLapFrames
			localCurrentLapMilliseconds -= t
			localCurrentLapMilliseconds *= 1000
			localCurrentLapMilliseconds /= 60
			-- # Set Current Local Lap time #


			-- # Display the players current lap time #
			if localCurrentLapMilliseconds >= 100 then
				bottomMiddleWidget.set_text("%n.%n", localCurrentLapSeconds, localCurrentLapMilliseconds )
			end
			if localCurrentLapMilliseconds < 100 then
				bottomMiddleWidget.set_text("%n.0%n", localCurrentLapSeconds, localCurrentLapMilliseconds )
			end
			-- # Display the players current lap time #


			-- # Increment the player frame counters #
			localLapFrames += 1 -- lapFrames
			-- # Increment the player frame counters #


			-- # Player has completed a lap #
			if localLapFrames > 15 and client.onVehicle == 1 then
				for each object with label "race_flag" do
					if current_object.order == timing.currentCheckpoint and timing.currentCheckpoint == finalCheckpoint.order then
						if current_object.shape_contains(client.biped) then
							localLapFrames = 0
						end
					end
				end
			end
			-- # Player has completed a lap #


			-- # Update Vehicle Speed #
			client.vehicleSpeedKPH = 0
			if client.onVehicle == 1 and client.biped != no_object then
				client.vehicleSpeedKPH = client.biped.get_speed()
				client.vehicleSpeedKPH *= 109 -- Convert from Feet Per Second to KPH
				client.vehicleSpeedKPH /= 100 -- Convert from Feet Per Second to KPH

				if client.vehicleSpeedKPH < 0 then
					client.vehicleSpeedKPH = 0
				end
				if client.vehicleSpeedKPH > 200 then
					client.vehicleSpeedKPH = 200
				end
			end
			-- # Update Vehicle Speed #

		end


	end
end



on host migration: do


		--	# Hide Invisible Race Objects #
		for each object with label "race_hide" do
			current_object.set_hidden(true)
		end
		--	# Hide Invisible Race Objects #



		-- # Delete Race Gates #
		for each object with label "race_gate" do
			current_object.delete()
		end
		-- # Delete Race Gates #



end